/**
    * Earthstar v10.2.2
    * https://earthstar-project.org
    *
    * This source code is licensed under the LGPL-3.0 license. 
  */
  
  
var ws=Object.create;var pr=Object.defineProperty;var bs=Object.getOwnPropertyDescriptor;var Ts=Object.getOwnPropertyNames;var vs=Object.getPrototypeOf,As=Object.prototype.hasOwnProperty;var Ss=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),fr=(r,e)=>{for(var t in e)pr(r,t,{get:e[t],enumerable:!0})},Ds=(r,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of Ts(e))!As.call(r,s)&&s!==t&&pr(r,s,{get:()=>e[s],enumerable:!(n=bs(e,s))||n.enumerable});return r};var xs=(r,e,t)=>(t=r!=null?ws(vs(r)):{},Ds(e||!r||!r.__esModule?pr(t,"default",{value:r,enumerable:!0}):t,r));var nn=Ss((aa,rn)=>{"use strict";rn.exports=function(r,e){e||(e={}),typeof e=="function"&&(e={cmp:e});var t=typeof e.cycles=="boolean"?e.cycles:!1,n=e.cmp&&function(i){return function(a){return function(o,c){var l={key:o,value:a[o]},h={key:c,value:a[c]};return i(l,h)}}}(e.cmp),s=[];return function i(a){if(a&&a.toJSON&&typeof a.toJSON=="function"&&(a=a.toJSON()),a!==void 0){if(typeof a=="number")return isFinite(a)?""+a:"null";if(typeof a!="object")return JSON.stringify(a);var o,c;if(Array.isArray(a)){for(c="[",o=0;o<a.length;o++)o&&(c+=","),c+=i(a[o])||"null";return c+"]"}if(a===null)return"null";if(s.indexOf(a)!==-1){if(t)return JSON.stringify("__cycle__");throw new TypeError("Converting circular structure to JSON")}var l=s.push(a)-1,h=Object.keys(a).sort(n&&n(a));for(c="",o=0;o<h.length;o++){var d=h[o],u=i(a[d]);u&&(c&&(c+=","),c+=JSON.stringify(d)+":"+u)}return s.splice(l,1),"{"+c+"}"}}(r)}});var P=class extends Error{constructor(e){super(e||""),this.name="EarthstarError"}},f=class extends P{constructor(e){super(e||"Validation error"),this.name="ValidationError"}},A=class extends P{constructor(e){super(e||"a Replica or ReplicaDriver was used after being closed"),this.name="ReplicaIsClosedError"}},ye=class extends P{constructor(e){super(e||"a ReplicaCache was used after being closed"),this.name="ReplicaCacheIsClosedError"}},Zr=class extends P{constructor(e){super(e||"network error"),this.name="NetworkError"}},Xr=class extends P{constructor(e){super(e||"timeout error"),this.name="TimeoutError"}},en=class extends P{constructor(e){super(e||"connection refused"),this.name="ConnectionRefused"}},tn=class extends P{constructor(e){super(e||"not implemented yet"),this.name="NotImplementedError"}},ce=class extends P{constructor(e){super(e||"Not supported"),this.name="NotSupportedError"}};function w(r){return r instanceof P}function mr(r){return!(r instanceof P)}function Me(r,e){if(r===e)return!0;if(!r||!e)return!1;var t=r.length;if(e.length!==t)return!1;for(var n=0;n<t;n++)if(r[n]!==e[n])return!1;return!0}function we(r,e){if(r===e)return!0;if(!r||!e)return!1;var t=Object.keys(r),n=Object.keys(e),s=t.length;if(n.length!==s)return!1;for(var i=0;i<s;i++){var a=t[i];if(r[a]!==e[a]||!Object.prototype.hasOwnProperty.call(e,a))return!1}return!0}var xr=xs(nn());var je={};fr(je,{base16:()=>Ms,base32:()=>_s,base32hex:()=>Ns,base64:()=>Us,base64url:()=>Os,codec:()=>Vs,default:()=>an});var Es=Object.create,sn=Object.defineProperty,Is=Object.getOwnPropertyDescriptor,ks=Object.getOwnPropertyNames,Bs=Object.getPrototypeOf,Rs=Object.prototype.hasOwnProperty,Cs=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),Ps=(r,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of ks(e))!Rs.call(r,s)&&s!==t&&sn(r,s,{get:()=>e[s],enumerable:!(n=Is(e,s))||n.enumerable});return r},Fs=(r,e,t)=>(t=r!=null?Es(Bs(r)):{},Ps(e||!r||!r.__esModule?sn(t,"default",{value:r,enumerable:!0}):t,r)),Ls=Cs(r=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0});function e(m,g,v){var S;if(v===void 0&&(v={}),!g.codes){g.codes={};for(var _=0;_<g.chars.length;++_)g.codes[g.chars[_]]=_}if(!v.loose&&m.length*g.bits&7)throw new SyntaxError("Invalid padding");for(var b=m.length;m[b-1]==="=";)if(--b,!v.loose&&!((m.length-b)*g.bits&7))throw new SyntaxError("Invalid padding");for(var D=new((S=v.out)!=null?S:Uint8Array)(b*g.bits/8|0),x=0,I=0,k=0,C=0;C<b;++C){var N=g.codes[m[C]];if(N===void 0)throw new SyntaxError("Invalid character "+m[C]);I=I<<g.bits|N,x+=g.bits,x>=8&&(x-=8,D[k++]=255&I>>x)}if(x>=g.bits||255&I<<8-x)throw new SyntaxError("Unexpected end of data");return D}function t(m,g,v){v===void 0&&(v={});for(var S=v,_=S.pad,b=_===void 0?!0:_,D=(1<<g.bits)-1,x="",I=0,k=0,C=0;C<m.length;++C)for(k=k<<8|255&m[C],I+=8;I>g.bits;)I-=g.bits,x+=g.chars[D&k>>I];if(I&&(x+=g.chars[D&k<<g.bits-I]),b)for(;x.length*g.bits&7;)x+="=";return x}var n={chars:"0123456789ABCDEF",bits:4},s={chars:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bits:5},i={chars:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bits:5},a={chars:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bits:6},o={chars:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bits:6},c={parse:function(m,g){return e(m.toUpperCase(),n,g)},stringify:function(m,g){return t(m,n,g)}},l={parse:function(m,g){return g===void 0&&(g={}),e(g.loose?m.toUpperCase().replace(/0/g,"O").replace(/1/g,"L").replace(/8/g,"B"):m,s,g)},stringify:function(m,g){return t(m,s,g)}},h={parse:function(m,g){return e(m,i,g)},stringify:function(m,g){return t(m,i,g)}},d={parse:function(m,g){return e(m,a,g)},stringify:function(m,g){return t(m,a,g)}},u={parse:function(m,g){return e(m,o,g)},stringify:function(m,g){return t(m,o,g)}},p={parse:e,stringify:t};r.base16=c,r.base32=l,r.base32hex=h,r.base64=d,r.base64url=u,r.codec=p}),_e=Fs(Ls(),1),Ms=_e.default.base16,_s=_e.default.base32,Ns=_e.default.base32hex,Us=_e.default.base64,Os=_e.default.base64url,Vs=_e.default.codec,an=_e.default;var kt={};fr(kt,{Hash:()=>Ys,__esModule:()=>Js,createHash:()=>Zs,default:()=>un});var qs=Object.create,cn=Object.defineProperty,Ks=Object.getOwnPropertyDescriptor,Ws=Object.getOwnPropertyNames,$s=Object.getPrototypeOf,Qs=Object.prototype.hasOwnProperty,js=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),Hs=(r,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of Ws(e))!Qs.call(r,s)&&s!==t&&cn(r,s,{get:()=>e[s],enumerable:!(n=Ks(e,s))||n.enumerable});return r},zs=(r,e,t)=>(t=r!=null?qs($s(r)):{},Hs(e||!r||!r.__esModule?cn(t,"default",{value:r,enumerable:!0}):t,r)),Gs=js(r=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.Hash=r.createHash=void 0;var e=[1116352408,1899447441,-1245643825,-373957723,961987163,1508970993,-1841331548,-1424204075,-670586216,310598401,607225278,1426881987,1925078388,-2132889090,-1680079193,-1046744716,-459576895,-272742522,264347078,604807628,770255983,1249150122,1555081692,1996064986,-1740746414,-1473132947,-1341970488,-1084653625,-958395405,-710438585,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,-2117940946,-1838011259,-1564481375,-1474664885,-1035236496,-949202525,-778901479,-694614492,-200395387,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,-2067236844,-1933114872,-1866530822,-1538233109,-1090935817,-965641998],t={sha256:1};function n(b){if(b&&!t[b]&&!t[b.toLowerCase()])throw new Error("Digest method not supported");return new s}r.createHash=n;var s=class{constructor(){this.A=1779033703,this.B=-1150833019,this.C=1013904242,this.D=-1521486534,this.E=1359893119,this.F=-1694144372,this.G=528734635,this.H=1541459225,this._size=0,this._sp=0,(!a||o>=8e3)&&(a=new ArrayBuffer(8e3),o=0),this._byte=new Uint8Array(a,o,80),this._word=new Int32Array(a,o,20),o+=80}update(b){if(typeof b=="string")return this._utf8(b);if(b==null)throw new TypeError("Invalid type: "+typeof b);let D=b.byteOffset,x=b.byteLength,I=x/64|0,k=0;if(I&&!(D&3)&&!(this._size%64)){let C=new Int32Array(b.buffer,D,I*16);for(;I--;)this._int32(C,k>>2),k+=64;this._size+=k}if(b.BYTES_PER_ELEMENT!==1&&b.buffer){let C=new Uint8Array(b.buffer,D+k,x-k);return this._uint8(C)}return k===x?this:this._uint8(b,k)}_uint8(b,D){let{_byte:x,_word:I}=this,k=b.length;for(D=D|0;D<k;){let C=this._size%64,N=C;for(;D<k&&N<64;)x[N++]=b[D++];N>=64&&this._int32(I),this._size+=N-C}return this}_utf8(b){let{_byte:D,_word:x}=this,I=b.length,k=this._sp;for(let C=0;C<I;){let N=this._size%64,U=N;for(;C<I&&U<64;){let M=b.charCodeAt(C++)|0;M<128?D[U++]=M:M<2048?(D[U++]=192|M>>>6,D[U++]=128|M&63):M<55296||M>57343?(D[U++]=224|M>>>12,D[U++]=128|M>>>6&63,D[U++]=128|M&63):k?(M=((k&1023)<<10)+(M&1023)+65536,D[U++]=240|M>>>18,D[U++]=128|M>>>12&63,D[U++]=128|M>>>6&63,D[U++]=128|M&63,k=0):k=M}U>=64&&(this._int32(x),x[0]=x[16]),this._size+=U-N}return this._sp=k,this}_int32(b,D){let{A:x,B:I,C:k,D:C,E:N,F:U,G:M,H:oe}=this,Y=0;for(D=D|0;Y<16;)i[Y++]=d(b[D++]);for(Y=16;Y<64;Y++)i[Y]=S(i[Y-2])+i[Y-7]+v(i[Y-15])+i[Y-16]|0;for(Y=0;Y<64;Y++){let Yr=oe+g(N)+u(N,U,M)+e[Y]+i[Y]|0,ys=m(x)+p(x,I,k)|0;oe=M,M=U,U=N,N=C+Yr|0,C=k,k=I,I=x,x=Yr+ys|0}this.A=x+this.A|0,this.B=I+this.B|0,this.C=k+this.C|0,this.D=C+this.D|0,this.E=N+this.E|0,this.F=U+this.F|0,this.G=M+this.G|0,this.H=oe+this.H|0}digest(b){let{_byte:D,_word:x}=this,I=this._size%64|0;for(D[I++]=128;I&3;)D[I++]=0;if(I>>=2,I>14){for(;I<16;)x[I++]=0;I=0,this._int32(x)}for(;I<16;)x[I++]=0;let k=this._size*8,C=(k&4294967295)>>>0,N=(k-C)/4294967296;return N&&(x[14]=d(N)),C&&(x[15]=d(C)),this._int32(x),b==="hex"?this._hex():this._bin()}_hex(){let{A:b,B:D,C:x,D:I,E:k,F:C,G:N,H:U}=this;return c(b)+c(D)+c(x)+c(I)+c(k)+c(C)+c(N)+c(U)}_bin(){let{A:b,B:D,C:x,D:I,E:k,F:C,G:N,H:U,_byte:M,_word:oe}=this;return oe[0]=d(b),oe[1]=d(D),oe[2]=d(x),oe[3]=d(I),oe[4]=d(k),oe[5]=d(C),oe[6]=d(N),oe[7]=d(U),M.slice(0,32)}};r.Hash=s;var i=new Int32Array(64),a,o=0,c=b=>(b+4294967296).toString(16).substr(-8),l=b=>b<<24&4278190080|b<<8&16711680|b>>8&65280|b>>24&255,h=b=>b,d=_()?h:l,u=(b,D,x)=>x^b&(D^x),p=(b,D,x)=>b&D|x&(b|D),m=b=>(b>>>2|b<<30)^(b>>>13|b<<19)^(b>>>22|b<<10),g=b=>(b>>>6|b<<26)^(b>>>11|b<<21)^(b>>>25|b<<7),v=b=>(b>>>7|b<<25)^(b>>>18|b<<14)^b>>>3,S=b=>(b>>>17|b<<15)^(b>>>19|b<<13)^b>>>10;function _(){return new Uint8Array(new Uint16Array([65279]).buffer)[0]===254}}),ln=zs(Gs()),Js=!0,{Hash:Ys,createHash:Zs}=ln,{default:on,...Xs}=ln,un=on!==void 0?on:Xs;var Oe={};fr(Oe,{CURVE:()=>L,ExtendedPoint:()=>W,Point:()=>V,RistrettoPoint:()=>Ne,getPublicKey:()=>wn,sign:()=>bn,utils:()=>dt,verify:()=>Tn});var K=BigInt(0),B=BigInt(1),Z=BigInt(2),fn=BigInt(255),dn=Z**BigInt(252)+BigInt("27742317777372353535851937790883648493"),L={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),P:Z**fn-BigInt(19),l:dn,n:dn,h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")};var mn=Z**BigInt(256),ct=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),fa=BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742"),ei=BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),ti=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),ri=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),ni=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),Q=class{constructor(e,t,n,s){this.x=e;this.y=t;this.z=n;this.t=s}static fromAffine(e){if(!(e instanceof V))throw new TypeError("ExtendedPoint#fromAffine: expected Point");return e.equals(V.ZERO)?Q.ZERO:new Q(e.x,e.y,B,y(e.x*e.y))}static toAffineBatch(e){let t=ai(e.map(n=>n.z));return e.map((n,s)=>n.toAffine(t[s]))}static normalizeZ(e){return this.toAffineBatch(e).map(this.fromAffine)}equals(e){hn(e);let{x:t,y:n,z:s}=this,{x:i,y:a,z:o}=e,c=y(t*o),l=y(i*s),h=y(n*o),d=y(a*s);return c===l&&h===d}negate(){return new Q(y(-this.x),this.y,this.z,y(-this.t))}double(){let{x:e,y:t,z:n}=this,{a:s}=L,i=y(e**Z),a=y(t**Z),o=y(Z*y(n**Z)),c=y(s*i),l=y(y((e+t)**Z)-i-a),h=c+a,d=h-o,u=c-a,p=y(l*d),m=y(h*u),g=y(l*u),v=y(d*h);return new Q(p,m,v,g)}add(e){hn(e);let{x:t,y:n,z:s,t:i}=this,{x:a,y:o,z:c,t:l}=e,h=y((n-t)*(o+a)),d=y((n+t)*(o-a)),u=y(d-h);if(u===K)return this.double();let p=y(s*Z*l),m=y(i*Z*c),g=m+p,v=d+h,S=m-p,_=y(g*u),b=y(v*S),D=y(g*S),x=y(u*v);return new Q(_,b,x,D)}subtract(e){return this.add(e.negate())}precomputeWindow(e){let t=1+256/e,n=[],s=this,i=s;for(let a=0;a<t;a++){i=s,n.push(i);for(let o=1;o<2**(e-1);o++)i=i.add(s),n.push(i);s=i.double()}return n}wNAF(e,t){!t&&this.equals(Q.BASE)&&(t=V.BASE);let n=t&&t._WINDOW_SIZE||1;if(256%n)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let s=t&&br.get(t);s||(s=this.precomputeWindow(n),t&&n!==1&&(s=Q.normalizeZ(s),br.set(t,s)));let i=Q.ZERO,a=Q.ZERO,o=1+256/n,c=2**(n-1),l=BigInt(2**n-1),h=2**n,d=BigInt(n);for(let u=0;u<o;u++){let p=u*c,m=Number(e&l);if(e>>=d,m>c&&(m-=h,e+=B),m===0){let g=s[p];u%2&&(g=g.negate()),a=a.add(g)}else{let g=s[p+Math.abs(m)-1];m<0&&(g=g.negate()),i=i.add(g)}}return Q.normalizeZ([i,a])[0]}multiply(e,t){return this.wNAF(Bt(e,L.l),t)}multiplyUnsafe(e){let t=Bt(e,L.l,!1),n=Q.BASE,s=Q.ZERO;if(t===K)return s;if(this.equals(s)||t===B)return this;if(this.equals(n))return this.wNAF(t);let i=s,a=this;for(;t>K;)t&B&&(i=i.add(a)),a=a.double(),t>>=B;return i}isSmallOrder(){return this.multiplyUnsafe(L.h).equals(Q.ZERO)}isTorsionFree(){return this.multiplyUnsafe(L.l).equals(Q.ZERO)}toAffine(e=Rt(this.z)){let{x:t,y:n,z:s}=this,i=y(t*e),a=y(n*e);if(y(s*e)!==B)throw new Error("invZ was invalid");return new V(i,a)}fromRistrettoBytes(){yr()}toRistrettoBytes(){yr()}fromRistrettoHash(){yr()}},W=Q;W.BASE=new Q(L.Gx,L.Gy,B,y(L.Gx*L.Gy)),W.ZERO=new Q(K,B,B,K);function hn(r){if(!(r instanceof W))throw new TypeError("ExtendedPoint expected")}function gr(r){if(!(r instanceof Ne))throw new TypeError("RistrettoPoint expected")}function yr(){throw new Error("Legacy method: switch to RistrettoPoint")}var Te=class{constructor(e){this.ep=e}static calcElligatorRistrettoMap(e){let{d:t}=L,n=y(ct*e*e),s=y((n+B)*ri),i=BigInt(-1),a=y((i-t*n)*y(n+t)),{isValid:o,value:c}=vr(s,a),l=y(c*e);Be(l)||(l=y(-l)),o||(c=l),o||(i=n);let h=y(i*(n-B)*ni-a),d=c*c,u=y((c+c)*a),p=y(h*ei),m=y(B-d),g=y(B+d);return new W(y(u*g),y(m*p),y(p*g),y(u*m))}static hashToCurve(e){e=Re(e,64);let t=wr(e.slice(0,32)),n=this.calcElligatorRistrettoMap(t),s=wr(e.slice(32,64)),i=this.calcElligatorRistrettoMap(s);return new Te(n.add(i))}static fromHex(e){e=Re(e,32);let{a:t,d:n}=L,s="RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint",i=wr(e);if(!ci(lt(i),e)||Be(i))throw new Error(s);let a=y(i*i),o=y(B+t*a),c=y(B-t*a),l=y(o*o),h=y(c*c),d=y(t*n*l-h),{isValid:u,value:p}=pn(y(d*h)),m=y(p*c),g=y(p*m*d),v=y((i+i)*m);Be(v)&&(v=y(-v));let S=y(o*g),_=y(v*S);if(!u||Be(_)||S===K)throw new Error(s);return new Te(new W(v,S,B,_))}toRawBytes(){let{x:e,y:t,z:n,t:s}=this.ep,i=y(y(n+t)*y(n-t)),a=y(e*t),{value:o}=pn(y(i*a**Z)),c=y(o*i),l=y(o*a),h=y(c*l*s),d;if(Be(s*h)){let p=y(t*ct),m=y(e*ct);e=p,t=m,d=y(c*ti)}else d=l;Be(e*h)&&(t=y(-t));let u=y((n-t)*d);return Be(u)&&(u=y(-u)),lt(u)}toHex(){return ut(this.toRawBytes())}toString(){return this.toHex()}equals(e){gr(e);let t=this.ep,n=e.ep,s=y(t.x*n.y)===y(t.y*n.x),i=y(t.y*n.y)===y(t.x*n.x);return s||i}add(e){return gr(e),new Te(this.ep.add(e.ep))}subtract(e){return gr(e),new Te(this.ep.subtract(e.ep))}multiply(e){return new Te(this.ep.multiply(e))}multiplyUnsafe(e){return new Te(this.ep.multiplyUnsafe(e))}},Ne=Te;Ne.BASE=new Te(W.BASE),Ne.ZERO=new Te(W.ZERO);var br=new WeakMap,He=class{constructor(e,t){this.x=e;this.y=t}_setWindowSize(e){this._WINDOW_SIZE=e,br.delete(this)}static fromHex(e,t=!0){let{d:n,P:s}=L;e=Re(e,32);let i=e.slice();i[31]=e[31]&-129;let a=ze(i);if(t&&a>=s)throw new Error("Expected 0 < hex < P");if(!t&&a>=mn)throw new Error("Expected 0 < hex < 2**256");let o=y(a*a),c=y(o-B),l=y(n*o+B),{isValid:h,value:d}=vr(c,l);if(!h)throw new Error("Point.fromHex: invalid y coordinate");let u=(d&B)===B;return(e[31]&128)!==0!==u&&(d=y(-d)),new He(d,a)}static async fromPrivateKey(e){return(await Ct(e)).point}toRawBytes(){let e=lt(this.y);return e[31]|=this.x&B?128:0,e}toHex(){return ut(this.toRawBytes())}toX25519(){let{y:e}=this,t=y((B+e)*Rt(B-e));return lt(t)}isTorsionFree(){return W.fromAffine(this).isTorsionFree()}equals(e){return this.x===e.x&&this.y===e.y}negate(){return new He(y(-this.x),this.y)}add(e){return W.fromAffine(this).add(W.fromAffine(e)).toAffine()}subtract(e){return this.add(e.negate())}multiply(e){return W.fromAffine(this).multiply(e,this).toAffine()}},V=He;V.BASE=new He(L.Gx,L.Gy),V.ZERO=new He(K,B);var Ue=class{constructor(e,t){this.r=e;this.s=t;this.assertValidity()}static fromHex(e){let t=Re(e,64),n=V.fromHex(t.slice(0,32),!1),s=ze(t.slice(32,64));return new Ue(n,s)}assertValidity(){let{r:e,s:t}=this;if(!(e instanceof V))throw new Error("Expected Point instance");return Bt(t,L.l,!1),this}toRawBytes(){let e=new Uint8Array(64);return e.set(this.r.toRawBytes()),e.set(lt(this.s),32),e}toHex(){return ut(this.toRawBytes())}};function si(...r){if(!r.every(n=>n instanceof Uint8Array))throw new Error("Expected Uint8Array list");if(r.length===1)return r[0];let e=r.reduce((n,s)=>n+s.length,0),t=new Uint8Array(e);for(let n=0,s=0;n<r.length;n++){let i=r[n];t.set(i,s),s+=i.length}return t}var ii=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function ut(r){if(!(r instanceof Uint8Array))throw new Error("Uint8Array expected");let e="";for(let t=0;t<r.length;t++)e+=ii[r[t]];return e}function gn(r){if(typeof r!="string")throw new TypeError("hexToBytes: expected string, got "+typeof r);if(r.length%2)throw new Error("hexToBytes: received invalid unpadded hex");let e=new Uint8Array(r.length/2);for(let t=0;t<e.length;t++){let n=t*2,s=r.slice(n,n+2),i=Number.parseInt(s,16);if(Number.isNaN(i)||i<0)throw new Error("Invalid byte sequence");e[t]=i}return e}function yn(r){let t=r.toString(16).padStart(64,"0");return gn(t)}function lt(r){return yn(r).reverse()}function Be(r){return(y(r)&B)===B}function ze(r){if(!(r instanceof Uint8Array))throw new Error("Expected Uint8Array");return BigInt("0x"+ut(Uint8Array.from(r).reverse()))}function wr(r){return y(ze(r)&Z**fn-B)}function y(r,e=L.P){let t=r%e;return t>=K?t:e+t}function Rt(r,e=L.P){if(r===K||e<=K)throw new Error(`invert: expected positive integers, got n=${r} mod=${e}`);let t=y(r,e),n=e,s=K,i=B,a=B,o=K;for(;t!==K;){let l=n/t,h=n%t,d=s-a*l,u=i-o*l;n=t,t=h,s=a,i=o,a=d,o=u}if(n!==B)throw new Error("invert: does not exist");return y(s,e)}function ai(r,e=L.P){let t=new Array(r.length),n=r.reduce((i,a,o)=>a===K?i:(t[o]=i,y(i*a,e)),B),s=Rt(n,e);return r.reduceRight((i,a,o)=>a===K?i:(t[o]=y(i*t[o],e),y(i*a,e)),s),t}function be(r,e){let{P:t}=L,n=r;for(;e-- >K;)n*=n,n%=t;return n}function oi(r){let{P:e}=L,t=BigInt(5),n=BigInt(10),s=BigInt(20),i=BigInt(40),a=BigInt(80),c=r*r%e*r%e,l=be(c,Z)*c%e,h=be(l,B)*r%e,d=be(h,t)*h%e,u=be(d,n)*d%e,p=be(u,s)*u%e,m=be(p,i)*p%e,g=be(m,a)*m%e,v=be(g,a)*m%e,S=be(v,n)*d%e;return{pow_p_5_8:be(S,Z)*r%e,b2:c}}function vr(r,e){let t=y(e*e*e),n=y(t*t*e),s=oi(r*n).pow_p_5_8,i=y(r*t*s),a=y(e*i*i),o=i,c=y(i*ct),l=a===r,h=a===y(-r),d=a===y(-r*ct);return l&&(i=o),(h||d)&&(i=c),Be(i)&&(i=y(-i)),{isValid:l||h,value:i}}function pn(r){return vr(B,r)}async function Tr(...r){let e=await dt.sha512(si(...r)),t=ze(e);return y(t,L.l)}function ci(r,e){if(r.length!==e.length)return!1;for(let t=0;t<r.length;t++)if(r[t]!==e[t])return!1;return!0}function Re(r,e){let t=r instanceof Uint8Array?Uint8Array.from(r):gn(r);if(typeof e=="number"&&t.length!==e)throw new Error(`Expected ${e} bytes`);return t}function Bt(r,e,t=!0){if(!e)throw new TypeError("Specify max value");if(typeof r=="number"&&Number.isSafeInteger(r)&&(r=BigInt(r)),typeof r=="bigint"&&r<e){if(t){if(K<r)return r}else if(K<=r)return r}throw new TypeError("Expected valid scalar: 0 < scalar < max")}function li(r){return r[0]&=248,r[31]&=127,r[31]|=64,r}async function Ct(r){if(r=typeof r=="bigint"||typeof r=="number"?yn(Bt(r,mn)):Re(r),r.length!==32)throw new Error("Expected 32 bytes");let e=await dt.sha512(r),t=li(e.slice(0,32)),n=e.slice(32,64),s=y(ze(t),L.l),i=V.BASE.multiply(s),a=i.toRawBytes();return{head:t,prefix:n,scalar:s,point:i,pointBytes:a}}async function wn(r){return(await Ct(r)).pointBytes}async function bn(r,e){r=Re(r);let{prefix:t,scalar:n,pointBytes:s}=await Ct(e),i=await Tr(t,r),a=V.BASE.multiply(i),o=await Tr(a.toRawBytes(),s,r),c=y(i+o*n,L.l);return new Ue(a,c).toRawBytes()}async function Tn(r,e,t){e=Re(e),t instanceof V||(t=V.fromHex(t,!1));let{r:n,s}=r instanceof Ue?r.assertValidity():Ue.fromHex(r),i=W.BASE.multiplyUnsafe(s),a=await Tr(n.toRawBytes(),t.toRawBytes(),e),o=W.fromAffine(t).multiplyUnsafe(a);return W.fromAffine(n).add(o).subtract(i).multiplyUnsafe(L.h).equals(W.ZERO)}V.BASE._setWindowSize(8);var dt={TORSION_SUBGROUP:["0100000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a","0000000000000000000000000000000000000000000000000000000000000080","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05","ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85","0000000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"],bytesToHex:ut,getExtendedPublicKey:Ct,mod:y,invert:Rt,hashToPrivateScalar:r=>{if(r=Re(r),r.length<40||r.length>1024)throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");let e=y(ze(r),L.l);if(e===K||e===B)throw new Error("Invalid private key");return e},randomBytes:(r=32)=>crypto.getRandomValues(new Uint8Array(r)),randomPrivateKey:()=>dt.randomBytes(32),sha512:async r=>{let e=await crypto.subtle.digest("SHA-512",r.buffer);return new Uint8Array(e)},precompute(r=8,e=V.BASE){let t=e.equals(V.BASE)?e:new V(e.x,e.y);return t._setWindowSize(r),t.multiply(Z),t}};var O=11400714785074694791n,H=14029467366897019727n,vn=1609587929392839161n,ht=9650029242287828579n,An=2870177450012600261n,Dn=64n,ui=2n**Dn-1n,di=new TextEncoder;function Sn(r,e,t,n){return BigInt(r)|BigInt(e)<<16n|BigInt(t)<<32n|BigInt(n)<<48n}function Se(r,e){return BigInt(r[e])|BigInt(r[e+1])<<8n|BigInt(r[e+2])<<16n|BigInt(r[e+3])<<24n|BigInt(r[e+4])<<32n|BigInt(r[e+5])<<40n|BigInt(r[e+6])<<48n|BigInt(r[e+7])<<56n}function q(r,e){return r<<e&ui|r>>Dn-e}function E(r){return BigInt.asUintN(64,r)}var Ce=class{#t;#n;#e;#i;#s;#a;#o;#r;constructor(e=0){this.reset(e)}reset(e=this.#t){return this.#t=BigInt.asUintN(32,BigInt(e)),this.#n=E(this.#t+O+H),this.#e=E(this.#t+H),this.#i=this.#t,this.#s=E(this.#t-O),this.#a=null,this.#o=0,this.#r=0,this}update(e){typeof e=="string"&&(e=di.encode(e));let t=0,n=e.length,s=t+n;if(n===0)return this;if(this.#o+=n,this.#r===0&&(this.#a=new Uint8Array(32)),this.#r+n<32)return this.#a.set(e.subarray(0,n),this.#r),this.#r+=n,this;if(this.#r>0){this.#a.set(e.subarray(0,32-this.#r),this.#r);let i=0,a;a=Se(this.#a,i),this.#n=E(q(E(this.#n+a*H),31n)*O),i+=8,a=Se(this.memory,i),this.#e=E(q(E(this.#e+a*H),31n)*O),i+=8,a=Se(this.memory,i),this.#i=E(q(E(this.#i+a*H),31n)*O),i+=8,a=Se(this.memory,i),this.#s=E(q(E(this.#s+a*H),31n)*O),t+=32-this.#r,this.#r=0}if(t<=s-32){let i=s-32;do{let a;a=Se(e,t),this.#n=E(q(E(this.#n+a*H),31n)*O),t+=8,a=Se(e,t),this.#e=E(q(E(this.#e+a*H),31n)*O),t+=8,a=Se(e,t),this.#i=E(q(E(this.#i+a*H),31n)*O),t+=8,a=Se(e,t),this.#s=E(q(E(this.#s+a*H),31n)*O),t+=8}while(t<=i)}return t<s&&(this.#a.set(e.subarray(t,s),this.#r),this.#r=s-t),this}digest(){let e=this.#a,t=this.#r,n=0,s=0n,i=0n,a=0n;for(this.#o>=32?(s=q(this.#n,1n)+q(this.#e,7n)+q(this.#i,12n)+q(this.#s,18n),s=E(s^q(E(this.#n*H),31n)*O),s=E(s*O+ht),s=E(s^q(E(this.#e*H),31n)*O),s=E(s*O+ht),s=E(s^q(E(this.#i*H),31n)*O),s=E(s*O+ht),s=E(s^q(E(this.#s*H),31n)*O),s=E(s*O+ht)):s=E(this.#t+An),s+=BigInt(this.#o);n<=t-8;)a=Se(e,n),a=E(q(E(a*H),31n)*O),s=E(q(s^a,27n)*O+ht),n+=8;for(n+4<=t&&(a=Sn(e[n+1]<<8|e[n],e[n+3]<<8|e[n+2],0,0),s=E(q(s^E(a*O),23n)*H+vn),n+=4);n<t;)a=Sn(e[n++],0,0,0),s=E(q(s^E(a*An),11n)*O);return i=E(s>>33n),s=E((s^i)*H),i=E(s>>29n),s=E((s^i)*vn),i=E(s>>32n),s=E(s^i),s}};function Ar(r,e=0){return new Ce(e).update(r).digest()}function Pt(r,e){return r<e?-1:r>e?1:0}var he=class{constructor(e,t){this.parent=e;this.value=t;this.left=null,this.right=null}static from(e){let t=new he(e.parent,e.value);return t.left=e.left,t.right=e.right,t}directionFromParent(){return this.parent===null?null:this===this.parent.left?"left":this===this.parent.right?"right":null}findMinNode(){let e=this.left;for(;e?.left;)e=e.left;return e??this}findMaxNode(){let e=this.right;for(;e?.right;)e=e.right;return e??this}findSuccessorNode(){if(this.right!==null)return this.right.findMinNode();let e=this.parent,t=this.directionFromParent();for(;e&&t==="right";)t=e.directionFromParent(),e=e.parent;return e}};var De=class{constructor(e=Pt){this.compare=e;this.root=null;this._size=0}static from(e,t){let n,s=[];if(e instanceof De)if(n=new De(t?.compare??e.compare),t?.compare||t?.map)s=e;else{let a=[];for(e.root&&(n.root=he.from(e.root),a.push(n.root));a.length;){let o=a.pop(),c=o.left?he.from(o.left):null,l=o.right?he.from(o.right):null;c&&(c.parent=o,a.push(c)),l&&(l.parent=o,a.push(l))}}else n=t?.compare?new De(t.compare):new De,s=e;let i=t?.map?Array.from(s,t.map,t.thisArg):s;for(let a of i)n.insert(a);return n}get size(){return this._size}findNode(e){let t=this.root;for(;t;){let n=this.compare(e,t.value);if(n===0)break;let s=n<0?"left":"right";t=t[s]}return t}rotateNode(e,t){let n=t==="left"?"right":"left";if(!e[n])throw new TypeError(`cannot rotate ${t} without ${n} child`);let s=e[n];if(e[n]=s[t]??null,s[t]&&(s[t].parent=e),s.parent=e.parent,e.parent){let i=e===e.parent[t]?t:n;e.parent[i]=s}else this.root=s;s[t]=e,e.parent=s}insertNode(e,t){if(this.root){let n=this.root;for(;;){let s=this.compare(t,n.value);if(s===0)break;let i=s<0?"left":"right";if(n[i])n=n[i];else return n[i]=new e(n,t),this._size++,n[i]}}else return this.root=new e(null,t),this._size++,this.root;return null}removeNode(e){let t=this.findNode(e);if(t){let n=!t.left||!t.right?t:t.findSuccessorNode(),s=n.left??n.right;s&&(s.parent=n.parent),n.parent?n.parent[n.directionFromParent()]=s:this.root=s,n!==t&&(t.value=n.value,t=n),this._size--}return t}insert(e){return!!this.insertNode(he,e)}remove(e){return!!this.removeNode(e)}find(e){return this.findNode(e)?.value??null}min(){return this.root?this.root.findMinNode().value:null}max(){return this.root?this.root.findMaxNode().value:null}clear(){this.root=null,this._size=0}isEmpty(){return this.size===0}*lnrValues(){let e=[],t=this.root;for(;e.length||t;)t?(e.push(t),t=t.left):(t=e.pop(),yield t.value,t=t.right)}*rnlValues(){let e=[],t=this.root;for(;e.length||t;)t?(e.push(t),t=t.right):(t=e.pop(),yield t.value,t=t.left)}*nlrValues(){let e=[];for(this.root&&e.push(this.root);e.length;){let t=e.pop();yield t.value,t.right&&e.push(t.right),t.left&&e.push(t.left)}}*lrnValues(){let e=[],t=this.root,n=null;for(;e.length||t;)if(t)e.push(t),t=t.left;else{let s=e[e.length-1];s.right&&s.right!==n?t=s.right:(yield s.value,n=e.pop())}}*lvlValues(){let e=[],t=this.root;for(;t;)yield t.value,t.left&&e.push(t.left),t.right&&e.push(t.right),t=e.shift()??null}*[Symbol.iterator](){yield*this.lnrValues()}};var pe=class extends he{constructor(t,n){super(t,n);this.red=!0}static from(t){let n=new pe(t.parent,t.value);return n.left=t.left,n.right=t.right,n.red=t.red,n}};var xe=class extends De{constructor(e=Pt){super(e)}static from(e,t){let n,s=[];if(e instanceof xe)if(n=new xe(t?.compare??e.compare),t?.compare||t?.map)s=e;else{let a=[];for(e.root&&(n.root=pe.from(e.root),a.push(n.root));a.length;){let o=a.pop(),c=o.left?pe.from(o.left):null,l=o.right?pe.from(o.right):null;c&&(c.parent=o,a.push(c)),l&&(l.parent=o,a.push(l))}}else n=t?.compare?new xe(t.compare):new xe,s=e;let i=t?.map?Array.from(s,t.map,t.thisArg):s;for(let a of i)n.insert(a);return n}removeFixup(e,t){for(;e&&!t?.red;){let n=e.left===t?"left":"right",s=n==="right"?"left":"right",i=e[s];i?.red&&(i.red=!1,e.red=!0,this.rotateNode(e,n),i=e[s]),i&&(!i.left?.red&&!i.right?.red?(i.red=!0,t=e,e=t.parent):(i[s]?.red||(i[n].red=!1,i.red=!0,this.rotateNode(i,s),i=e[s]),i.red=e.red,e.red=!1,i[s].red=!1,this.rotateNode(e,n),t=this.root,e=null))}t&&(t.red=!1)}insert(e){let t=this.insertNode(pe,e);if(t){for(;t.parent?.red;){let n=t.parent,s=n.directionFromParent(),i=s==="right"?"left":"right",a=n.parent[i]??null;a?.red?(n.red=!1,a.red=!1,n.parent.red=!0,t=n.parent):(t===n[i]&&(t=n,this.rotateNode(t,s),n=t.parent),n.red=!1,n.parent.red=!0,this.rotateNode(n.parent,i))}this.root.red=!1}return!!t}remove(e){let t=this.removeNode(e);return t&&!t.red&&this.removeFixup(t.parent,t.left??t.right),!!t}};function Ft(r,e){return{lift:t=>[r.lift(t),e.lift(t)],combine:(t,n)=>{let s=r.combine(t[0],n[0]),i=e.combine(t[1],n[1]);return[s,i]},neutral:[r.neutral,e.neutral]}}var xn={lift:r=>1,combine:(r,e)=>r+e,neutral:0};var Sr=!1,Lt=class extends pe{constructor(t,n,s){super(t,n);this.label=s.neutral,this.liftedValue=s.lift(n),this.monoid=s}updateLabel(t=!0,n){this.left!==null&&this.right===null?this.label=this.monoid.combine(this.left.label,this.liftedValue):this.left===null&&this.right!==null?this.label=this.monoid.combine(this.liftedValue,this.right.label):this.left&&this.right?this.label=this.monoid.combine(this.left.label,this.monoid.combine(this.liftedValue,this.right.label)):this.label=this.liftedValue,Sr&&(n&&console.log(n),console.group("Updating...",this.value),console.log("Lifted value",this.liftedValue),console.log("Label L",this.left?.label||this.monoid.neutral),console.log("Label R",this.right?.label||this.monoid.neutral),console.log("Label",this.label),console.groupEnd()),t&&this.parent?.updateLabel(!0,"Updated by child")}},pt=class extends xe{constructor(t,n){super(n);this.cachedMinNode=null;let a=Ft({lift:o=>[o],combine:(o,c)=>o.concat(c),neutral:[]},{lift:o=>o,combine:(o,c)=>{if(!(o===void 0&&c===void 0))return c===void 0?o:o===void 0?c:n(o,c)>0?o:c},neutral:void 0});this.monoid=Ft(t,Ft(xn,a))}getLowestValue(){if(!this.root)throw new Error("Can't get a range from a tree with no items");return this.cachedMinNode?this.cachedMinNode.value:this.root.findMinNode().value}rotateNode(t,n){let s=n==="left"?"right":"left";if(!t[s])throw new TypeError(`cannot rotate ${n} without ${s} child`);Sr&&console.group("Rotating",n);let i=t[s];if(t[s]=i[n]??null,i[n]&&(i[n].parent=t),i.parent=t.parent,t.parent){let a=t===t.parent[n]?n:s;t.parent[a]=i}else this.root=i;i[n]=t,t.parent=i,i[n]?.updateLabel(!1,"Node rotated"),Sr&&console.groupEnd()}removeFixup(t,n){for(;t&&!n?.red;){let s=t.left===n?"left":"right",i=s==="right"?"left":"right",a=t[i];a?.red&&(a.red=!1,t.red=!0,this.rotateNode(t,s),a=t[i]),a&&(!a.left?.red&&!a.right?.red?(a.red=!0,n=t,t=n.parent):(a[i]?.red||(a[s].red=!1,a.red=!0,this.rotateNode(a,i),a=t[i]),a.red=t.red,t.red=!1,a[i].red=!1,this.rotateNode(t,s),n=this.root,t=null))}n&&(n.red=!1)}insertFingerprintNode(t){if(this.root){let n=this.root,s=!0;for(;;){let i=this.compare(t,n.value);if(i===0){s=!1;break}let a=i<0?"left":"right";if(s&&a==="right"&&(s=!1),n[a])n=n[a];else return n[a]=new Lt(n,t,this.monoid),this._size++,s&&(this.cachedMinNode=n[a]),n[a]}}else return this.root=new Lt(null,t,this.monoid),this._size++,this.cachedMinNode=this.root,this.root;return null}insert(t){let n=this.insertFingerprintNode(t),s=n;if(s){for(;s.parent?.red;){let i=s.parent,a=i.directionFromParent(),o=a==="right"?"left":"right",c=i.parent[o]??null;c?.red?(i.red=!1,c.red=!1,i.parent.red=!0,s=i.parent):(s===i[o]&&(s=i,this.rotateNode(s,a),i=s.parent),i.red=!1,i.parent.red=!0,this.rotateNode(i.parent,o))}this.root.red=!1}return n?.updateLabel(!0,"Node inserted"),!!s}remove(t){let n=this.removeNode(t);return n&&!n.red&&this.removeFixup(n.parent,n.left??n.right),n&&n.parent?.updateLabel(!0,"Child node removed"),!!n}getFingerprint(t,n,s){if(this.root===null)return{fingerprint:this.monoid.neutral[0],size:0,items:[],nextTree:null};let i=this.compare(t,n);if(i===0)return{fingerprint:this.root.label[0],size:this.root.label[1][0],items:this.root.label[1][1][0],nextTree:this.cachedMinNode};if(i<0){let a=this.compare(t,this.cachedMinNode.value)<=0?this.cachedMinNode:null,o=s||a||this.findGteNode(t),{label:c,nextTree:l}=this.aggregateUntil(o,t,n);return{fingerprint:c[0],size:c[1][0],items:c[1][1][0],nextTree:l}}else{let a=this.cachedMinNode,o=this.root.label[1][1][1],c=this.compare(n,a.value)>0,l=this.compare(t,o)<=0;if(c&&l){let{label:h,nextTree:d}=this.aggregateUntil(a,a.value,n),p=[this.monoid.lift(o)[0],[1,[[o],o]]],m=s||this.findGteNode(t),{label:g}=this.aggregateUntil(m,t,o),v=this.monoid.combine(g,p),S=this.monoid.combine(h,v);return{fingerprint:S[0],size:S[1][0],items:S[1][1][0],nextTree:d}}else if(c){let{label:h,nextTree:d}=this.aggregateUntil(a,a.value,n);return{fingerprint:h[0],size:h[1][0],items:h[1][1][0],nextTree:d}}else{let h=this.compare(t,this.cachedMinNode.value)<=0?this.cachedMinNode:null,d=s||h||this.findGteNode(t),{label:u}=this.aggregateUntil(d,t,o),m=[this.monoid.lift(o)[0],[1,[[o],o]]],g=this.monoid.combine(u,m);return{fingerprint:g[0],size:g[1][0],items:g[1][1][0],nextTree:h}}}}findGteNode(t){let n=this.root;for(;n;){let s=this.compare(t,n.value);if(s===0)break;let i=s<0?"left":"right";if(n[i])n=n[i];else break}return n}aggregateUntil(t,n,s){let{label:i,nextTree:a}=this.aggregateUp(t,n,s);return a===null||this.compare(a.value,s)>=0?{label:i,nextTree:a}:this.aggregateDown(a.right,s,this.monoid.combine(i,a.liftedValue))}aggregateUp(t,n,s){let i=this.monoid.neutral,a=t;for(;this.compare(a.label[1][1][1],s)<0;){if(this.compare(a.value,n)>=0&&(i=this.monoid.combine(i,this.monoid.combine(a.liftedValue,a.right?.label||this.monoid.neutral))),a.parent===null)return{label:i,nextTree:null};a=a.parent}return{label:i,nextTree:a}}aggregateDown(t,n,s){let i=t,a=s;for(;i!==null;)if(this.compare(i.value,n)<0)a=this.monoid.combine(a,this.monoid.combine(i.left?.label||this.monoid.neutral,i.liftedValue)),i=i.right;else{if(i.left===null||this.compare(i.label[1][1][1],n)<0)return{label:this.monoid.combine(a,i.left?.label||this.monoid.neutral),nextTree:i};i=i.left}return{label:a,nextTree:null}}isValueEqual(t,n){return this.compare(t,n)===0}};function En(){let r,e="pending",t=new Promise((n,s)=>{r={async resolve(i){await i,e="fulfilled",n(i)},reject(i){e="rejected",s(i)}}});return Object.defineProperty(t,"state",{get:()=>e}),Object.assign(t,r)}var Mt=class{constructor(){this.deferreds=new Set;this.state="pending"}resolve(e){if(this.state==="pending"){this.state="fulfilled";for(let t of this.deferreds)t.resolve(e)}}reject(e){if(this.state==="pending"){this.state="rejected";for(let t of this.deferreds)t.reject(e)}}tee(){let e=En();return this.state==="fulfilled"?e.resolve():this.state==="rejected"?e.reject():this.deferreds.add(e),e}};var ft=class{constructor(e){this.isDoneTee=new Mt;this.insertionCallbacks=new Set;this.lowerBoundFromPrev=null;this.collatedPayload=null;this.collatePayloads=e=>{switch(e.type){case"payload":{let t=this.collatedPayload;if(t===null&&(t={type:"payload",lowerBound:e.lowerBound,payload:[],end:{canRespond:!1,upperBound:e.payload}}),t.payload.push(e.payload),this.collatedPayload=t,e.end)return e.end.upperBound?t.end=e.end:t.end={...e.end,upperBound:e.payload},this.collatedPayload=null,t;break}default:return this.collatedPayload&&(this.collatedPayload=null),e}};this.reusableTree=void 0;this.lastAdjacentDoneUpperBound=null;this.isDoneSoFar=!0;this.tree=e.tree,this.fingerprintEquals=e.fingerprintEquals,this.encoding=e.encoding,this.payloadThreshold=e.payloadThreshold,this.rangeDivision=e.rangeDivision}decode(e){let t=this.lowerBoundFromPrev;try{switch(this.encoding.decode.getType(e)){case"payload":{let s=this.encoding.decode.payload(e);return s.end&&(this.lowerBoundFromPrev=s.end.upperBound),{type:"payload",lowerBound:t,payload:s.value,...s.end?{end:s.end}:{}}}case"fingerprint":{let s=this.encoding.decode.fingerprint(e);return this.lowerBoundFromPrev=s.upperBound,{type:"fingerprint",lowerBound:t,fingerprint:s.fingerprint,upperBound:s.upperBound}}case"emptyPayload":{let s=this.encoding.decode.emptyPayload(e);return this.lowerBoundFromPrev=s,{lowerBound:t,type:"emptyPayload",upperBound:s}}case"done":{let s=this.encoding.decode.done(e);return this.lowerBoundFromPrev=s,{lowerBound:t,type:"done",upperBound:s}}case"emptySet":return{type:"emptySet",canRespond:this.encoding.decode.emptySet(e)};case"lowerBound":{let s=this.encoding.decode.lowerBound(e);return this.lowerBoundFromPrev=s,{type:"lowerBound",value:s}}case"terminal":return this.encoding.decode.terminal(e),{type:"terminal"}}}catch(n){console.group("range-reconcile: Could not decode message"),console.warn(e),console.warn(n)}return null}setReusableTree(e){this.reusableTree=e||void 0}process(e){let t=this.reusableTree;switch(e.type){case"lowerBound":case"terminal":case"done":return this.setReusableTree(null),[e];case"emptySet":{if(e.canRespond===!1&&this.isDoneTee.resolve(),this.tree.size===0)return[{type:"emptySet",canRespond:!1}];let n=this.tree.getLowestValue(),s=[{type:"lowerBound",value:n}],{items:i}=this.tree.getFingerprint(n,n);for(let a=0;a<i.length;a++){let o=i[a];a===i.length-1?s.push({type:"payload",payload:o,end:{upperBound:n,canRespond:!1}}):s.push({type:"payload",payload:o})}return s.push({type:"terminal"}),s}case"fingerprint":{let{fingerprint:n,size:s,items:i,nextTree:a}=this.tree.getFingerprint(e.lowerBound,e.upperBound,t);if(this.setReusableTree(a),this.fingerprintEquals(n,e.fingerprint))return[{type:"done",upperBound:e.upperBound}];if(s<=this.payloadThreshold){if(s===0)return[{type:"emptyPayload",upperBound:e.upperBound}];let o=[];for(let c=0;c<s;c++)o.push({type:"payload",payload:i[c],...c===i.length-1?{end:{upperBound:e.upperBound,canRespond:!0}}:{}});return o}else{let o=Math.ceil(s/this.rangeDivision),c=[];if(o<=this.payloadThreshold){for(let u=0;u<i.length;u++)c.push({type:"payload",payload:i[u],...u===i.length-1?{end:{upperBound:e.upperBound,canRespond:!0}}:{}});return c}let l,h=i,d=!1;if(e.lowerBound>=e.upperBound){let u=0;for(let p=0;p<=i.length;p++)if(i[p]>=e.lowerBound){u=p;break}if(u>0){let p=h.splice(0,u);h.push(...p),d=!0}}for(let u=0;u<s;u+=o){let p=h[u],m=h[u+o]||e.upperBound,{fingerprint:g,nextTree:v}=this.tree.getFingerprint(p,m,l);l=d?void 0:v||void 0,c.push({type:"fingerprint",fingerprint:g,upperBound:m})}return c}}case"payload":{for(let n of e.payload){this.tree.insert(n);for(let s of this.insertionCallbacks)s(n)}if(e.end.canRespond){let{items:n,size:s,nextTree:i}=this.tree.getFingerprint(e.lowerBound,e.end.upperBound,t);if(this.setReusableTree(i),s===0)return[{type:"emptyPayload",upperBound:e.end.upperBound}];let a=[];for(let c=0;c<s;c++){let l=!1;for(let h=0;h<e.payload.length;h++)this.tree.isValueEqual(n[c],e.payload[h])&&(l=!0);l||a.push({type:"payload",payload:n[c]})}let o=a[a.length-1];return a[a.length-1]={...o,end:{upperBound:e.end.upperBound,canRespond:!1}},a}else return this.setReusableTree(null),[{type:"done",upperBound:e.end.upperBound}]}case"emptyPayload":{this.setReusableTree(null);let{items:n,size:s,nextTree:i}=this.tree.getFingerprint(e.lowerBound,e.upperBound);if(this.setReusableTree(i),s===0)return this.setReusableTree(null),[];let a=[];for(let o=0;o<s;o++)a.push({type:"payload",payload:n[o],...o===n.length-1?{end:{upperBound:e.upperBound,canRespond:!1}}:{}});return a}}}consolidateAdjacentDones(e){switch(e.type){case"done":{this.lastAdjacentDoneUpperBound=e.upperBound;break}default:{let t=this.lastAdjacentDoneUpperBound;return t?(this.lastAdjacentDoneUpperBound=null,[{type:"done",upperBound:t},e]):[e]}}}checkIsDone(e){if(this.isDoneTee.state==="pending")switch(e.type){case"emptySet":{e.canRespond&&(this.isDoneSoFar=!1);break}case"lowerBound":break;case"fingerprint":this.isDoneSoFar=!1;break;case"emptyPayload":this.isDoneSoFar=!1;break;case"payload":e.end?.canRespond===!0&&(this.isDoneSoFar=!1);break;case"terminal":this.isDoneSoFar?this.isDoneTee.resolve():this.isDoneSoFar=!0}}encode(e){let t;switch(e.type){case"emptySet":{t=this.encoding.encode.emptySet(e.canRespond);break}case"lowerBound":{t=this.encoding.encode.lowerBound(e.value);break}case"done":{t=this.encoding.encode.done(e.upperBound);break}case"fingerprint":{t=this.encoding.encode.fingerprint(e.fingerprint,e.upperBound);break}case"payload":{t=this.encoding.encode.payload(e.payload,e.end);break}case"emptyPayload":{t=this.encoding.encode.emptyPayload(e.upperBound);break}case"terminal":{t=this.encoding.encode.terminal();break}}return t}respond(e){if(this.isDone().state==="fulfilled")return[];let t=this.decode(e),n=this.collatePayloads(t);if(n===void 0)return[];let s=this.process(n),i=[];for(let o of s){let c=this.consolidateAdjacentDones(o);c&&i.push(...c)}for(let o of i)this.checkIsDone(o);let a=[];for(let o of i)a.push(this.encode(o));return a}isDone(){return this.isDoneTee.tee()}initialMessages(e){let{tree:t,encoding:n,payloadThreshold:s,rangeDivision:i}=this;function*a(){if(t.size===0){yield n.encode.emptySet(!0);return}let o=t.getLowestValue();yield n.encode.lowerBound(o);let{items:l}=t.getFingerprint(o,o),d=(e||(m=>{let g=Math.ceil(m.length/i),v=[];for(let S=0;S<m.length;S+=g){let _=m.slice(S,S+g);v.push(_)}return v}))(l),u;for(let m=0;m<d.length;m++){let g=d[m+1]?d[m+1][0]:o,v=d[m];if(v.length<=s)for(let S=0;S<v.length;S++)yield n.encode.payload(v[S],S===v.length-1?{upperBound:g,canRespond:!0}:void 0);else{let S=v[0],{fingerprint:_,nextTree:b}=t.getFingerprint(S,g,u);u=b||void 0,yield n.encode.fingerprint(_,g)}}yield n.encode.terminal()}return a()}onInsertion(e){return this.insertionCallbacks.add(e),()=>{this.insertionCallbacks.delete(e)}}};var In=Symbol("Stream ended."),hi=Symbol("Stream errored."),_t=class{constructor(e){this.top=0;this.btm=0;this.next=null;if(!(e>0)||e-1&e)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){let e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}peek(){return this.buffer[this.btm]}isEmpty(){return this.buffer[this.btm]===void 0}},kn=class{constructor(e){this.resolve=null;this.hwm=e||16,this.head=new _t(this.hwm),this.tail=this.head}push(e){if(this.resolve){this.resolve(e),this.resolve=null;return}if(!this.head.push(e)){let t=this.head;this.head=t.next=new _t(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next){let t=this.tail.next;return this.tail.next=null,this.tail=t,this.tail.shift()}return e}peek(){return this.tail.peek()}isEmpty(){return this.head.isEmpty()}close(){this.push(In)}async*[Symbol.asyncIterator](){for(;;){let t=this.shift()||await new Promise(n=>{this.resolve=n});if(t===In||t===hi)break;yield t}}};var Bn=Symbol("Stream ended."),Dr=Symbol("Stream errored."),j=class{constructor(e){this.#t=[];this.#n=null;this.push=(...e)=>{e.length?this.#s(!1,e):(this.#s(!1,[Dr]),this.#i(new Error("AsyncQueueError: queue.push was called with no arguments")))};this.close=({immediately:e=!1,withError:t}={})=>{t&&this.#i(t),this.#s(e,[t?Dr:Bn]),this.push=this.close=()=>{}};e?.catch?.(t=>this.close({withError:t}))?.finally?.(()=>this.close())}#t;#n;#e;#i(e){this.#e instanceof AggregateError?this.#e.errors.push(e):this.#e?this.#e=new AggregateError([this.#e,e]):this.#e=e}#s(e,t){this.#t[e?"unshift":"push"](...t),this.#n?.(this.#t.shift()),this.#n=null}get length(){return this.#t.length}async*[Symbol.asyncIterator](){for(;;){let e=this.#t.length?this.#t.shift():await new Promise(t=>{this.#n=t});if(e===Dr)throw this.#e;if(e===Bn)break;yield e}}};function T(){let r,e="pending",t=new Promise((n,s)=>{r={async resolve(i){await i,e="fulfilled",n(i)},reject(i){e="rejected",s(i)}}});return Object.defineProperty(t,"state",{get:()=>e}),Object.assign(t,r)}var pi=new TextDecoder,fi=new TextEncoder;function go(r){return pi.decode(r)}function Ge(r){return fi.encode(r)}function Rn(r){return Ge(r).length}function yo(r,e){if(!e||e.length===0)return r;if(!r||r.length===0)return e;var t=new Uint8Array(r.length+e.length);return t.set(r),t.set(e,r.length),t}function wo(r){return je.base64.parse(r)}function mi(r){return r?.constructor?.name==="Uint8Array"}function gi(r){return r?.constructor?.name==="Buffer"}function bo(r){return mi(r)?"bytes":gi(r)?"buffer":"?"}function mt(r,e){for(let t of r)if(e.indexOf(t)===-1)return!1;return!0}function Ao(r){let e=Ge(r);for(let t of e)if(t<32||t>126)return!1;return!0}function Er(r){return r===""?!1:Nt.indexOf(r)!==-1}var Ve="abcdefghijklmnopqrstuvwxyz",yi=Ve.toUpperCase(),Nt="0123456789",le=Ve+"234567",Ir=Ve+Nt,Cn=le,Ut=Ir+le+"@.",kr=Ve+Nt,Ot=le,Vt=kr+le+"+.",wi="/'()-._~!$&+,:=@%",qt=Ve+yi+Nt+wi;function Kt(r,e){return`@${r}.${e}`}function Wt(r,e){return`+${r}.${e}`}function Je(r){let e=Pn(r);return mr(e)?!0:e}function X(r){let e=yt(r);return mr(e)?!0:e}function gt(r){return r.startsWith("@")?Pn(r):r.startsWith("+")?yt(r):new f("address must start with either @ or +")}function Pn(r){return Fn(r,{sigil:"@",separator:".",minNameLength:4,maxNameLength:4,minPubkeyLength:53,maxPubkeyLength:53,allowedNameCharacters:Ir,allowedPubkeyCharacters:Cn,pubkeyMustStartWithB:!0})}function yt(r){return Fn(r,{sigil:"+",separator:".",minNameLength:1,maxNameLength:15,minPubkeyLength:53,maxPubkeyLength:53,allowedNameCharacters:kr,allowedPubkeyCharacters:Ot,pubkeyMustStartWithB:!0})}function Fn(r,e){let{sigil:t,separator:n,minNameLength:s,maxNameLength:i,minPubkeyLength:a,maxPubkeyLength:o,allowedNameCharacters:c,allowedPubkeyCharacters:l,pubkeyMustStartWithB:h}=e;if(typeof r!="string")return new f("address must be a string");if(r.length<4)return new f("address is too short");if(r[0]!==t)return new f(`address must start with a sigil: "${t}"`);if(r.indexOf(n)===-1)return new f(`address must contain a separator character: "${n}"`);let d=r.slice(1).split(n);if(d.length!==2)return new f(`address must have exactly 2 parts separated by a "${n}" separator`);let[u,p]=d;return u.length<s||u.length>i?new f(`name must be between ${s} and ${i} characters long, but is ${u.length}`):p.length<a||p.length>o?new f(`pubkey must be between ${a} and ${o} characters long, but is ${p.length}`):mt(u,c)?mt(p,l)?Er(u[0])?new f(`name "${u}" must not start with a digit`):Er(p[0])?new f(`pubkey "${p}" must not start with a digit`):h&&p[0]!=="b"?new f(`pubkey "${p}" must start with 'b'`):{address:r,name:u,pubkey:p}:new f(`pubkey "${p}" must only have allowed characters`):new f(`name "${u}" must only have allowed characters`)}function Ye(r){return!(Object.prototype.toString.call(r)!=="[object Object]"||(""+r.constructor).startsWith("class"))}function Bo(r){return Ye(r)?null:"expected plain object but got "+r}function $t(r){return e=>e!==r?`expected literal value ${JSON.stringify(r)}`:null}function z(r={}){return e=>{if(r.optional!==!0&&e===void 0)return"required";if(r.optional===!0&&e===void 0)return null;let t=Rn(e);return typeof e!="string"?"expected a string but got "+JSON.stringify(e):r.minLen!==void 0&&t<r.minLen?`string shorter than min length of ${r.minLen} chars`:r.maxLen!==void 0&&t>r.maxLen?`string shorter than max length of ${r.maxLen} chars`:r.len!==void 0&&t!==r.len?`string does not have required length of ${r.len} chars: ${e}`:r.allowedChars!==void 0&&!mt(e,r.allowedChars)?"contains disallowed characters":null}}function qe(r={}){return e=>r.optional!==!0&&e===void 0?"required":r.optional===!0&&e===void 0?null:r.nullable!==!0&&e===null?"not nullable":r.nullable===!0&&e===null?null:typeof e!="number"?"expected a number but got "+JSON.stringify(e):isNaN(e)?"is NaN":isFinite(e)?e!==Math.round(e)?"expected an integer":r.min!==void 0&&e<r.min?`integer too small (must be >= ${r.min})`:r.max!==void 0&&e>r.max?`integer too large (must be <= ${r.max})`:null:"is Infinity"}function Qt(r={}){return r.allowLiteralUndefined=r.allowLiteralUndefined??!1,r.allowExtraKeys=r.allowExtraKeys??!1,e=>{if(!Ye(e))return"expected an object";if(r.allowLiteralUndefined===!1){for(let[t,n]of Object.entries(e))if(n===void 0)return`${t} is explicitly set to undefined but should be missing instead`}if(r.objSchema!==void 0){if(r.allowExtraKeys===!1){let t=Object.keys(e),n=Object.keys(r.objSchema),s=t.filter(i=>n.indexOf(i)===-1);if(s.length>0)return`object has extra keys not in the schema: ${s.join(", ")}`}for(let[t,n]of Object.entries(r.objSchema)){let s=n(e[t]);if(s!==null)return`${t}: ${s}`}}return null}}var{codec:Ln}=je,Mn={chars:"abcdefghijklmnopqrstuvwxyz234567",bits:5};function ue(r){return"b"+Ln.stringify(r,Mn,{pad:!1})}function Ze(r){if(!r.startsWith("b"))throw new f("can't decode base32 string - it should start with a 'b'. "+r);if(r[r.length-1]==="=")throw new f("can't decode base32 string - it contains padding characters ('=')");return Ln.parse(r.slice(1),Mn,{loose:!0})}var bi=(a=>(a[a.None=-1]="None",a[a.Error=0]="Error",a[a.Warn=1]="Warn",a[a.Log=2]="Log",a[a.Info=3]="Info",a[a.Debug=4]="Debug",a))(bi||{}),Ti=0,Pe={_default:Ti};function Lo(r){Pe={...Pe,...r}}function Mo(r,e){Pe[r]=e}function _o(r){Pe._default=r}function vi(r){return r in Pe?Pe[r]:Pe._default}function No(){return Pe}var R=class{constructor(e,t){this.color=void 0;this.source=e,this.color=t||"aqua"}_print(e,t,n,...s){if(e<=vi(this.source))if(t){let i=`[${this.source}]`;if(this.color!==void 0){let a=[`%c ${i}`,`color: ${this.color}`];console.log(n,...a,...s)}else console.log(n,i,...s)}else console.log(n,...s)}error(...e){this._print(0,!0,"!!",...e)}warn(...e){this._print(1,!0,"! ",...e)}log(...e){this._print(2,!0,"  ",...e)}info(...e){this._print(3,!0,"    ",...e)}debug(...e){this._print(4,!0,"      ",...e)}blank(){this._print(3,!1,"")}};var jt=class{constructor(e){this.hash=e.hash,this.internalUpdate=e.update,this.internalDigest=e.digest}update(e){return this.hash=this.internalUpdate(this.hash,e),this.hash}digest(){return this.internalDigest(this.hash)}};var{createHash:Br}=kt,Rr=new R("crypto-driver-noble","cyan"),_n=class{static sha256(r){return typeof r=="string"?Promise.resolve(Br("sha256").update(r,"utf-8").digest()):Promise.resolve(Br("sha256").update(r).digest())}static updatableSha256(){return new jt({hash:Br("sha256"),update:(r,e)=>r.update(e),digest:r=>r.digest()})}static async generateKeypairBytes(){Rr.debug("generateKeypairBytes");let r=Oe.utils.randomPrivateKey();return{pubkey:await Oe.getPublicKey(r),secret:r}}static sign(r,e){return Rr.debug("sign"),typeof e=="string"&&(e=Ge(e)),Oe.sign(e,r.secret)}static async verify(r,e,t){Rr.debug("verify");try{return typeof t=="string"&&(t=Ge(t)),await Oe.verify(e,t,r)}catch{return!1}}};function Cr(){return Date.now()*1e3}function Ht(r){return new Promise(e=>{setTimeout(e,r)})}function re(){return""+Math.floor(Math.random()*1e3)+Math.floor(Math.random()*1e3)}function wt(r,e,t){return r.split(e).join(t)}function Pr(r,e){if(e.length!=1)throw new Error("char must have length 1 but is "+JSON.stringify(e));return r.split(e).length-1}function Nn(r){return Object.keys(r).length===0}function Ho(r){let e=a=>a[Math.floor(Math.random()*a.length)],t=e(Ve),n=Array.from(Array(11),()=>e(Ot)).join(""),s=`${t}${n}`;return`+${r}.${s}`}function Zo(r,e){return{address:Kt(r,ue(e.pubkey)),secret:ue(e.secret)}}function Xo(r,e){return{address:Wt(r,ue(e.pubkey)),secret:ue(e.secret)}}function Un(r){try{let e=Fr(r)?r.address:r.shareAddress,t=gt(e);if(w(t))return t;let n={pubkey:Ze(t.pubkey),secret:Ze(r.secret)};return n.pubkey.length!==32?new f(`pubkey bytes should be 32 bytes long, not ${n.pubkey.length} after base32 decoding.  ${e}`):n.secret.length!==32?new f(`secret bytes should be 32 bytes long, not ${n.secret.length} after base32 decoding.  ${r.secret}`):n}catch(e){return new f("crash while decoding author keypair: "+e.message)}}function Fr(r){return"address"in r}var On=_n;var Ai=new R("crypto","cyan"),Fe=On;function ic(r){Ai.debug(`set global crypto driver: ${r.name}`),Fe=r}var bt=new R("crypto","cyan"),F=class{static async sha256base32(r){let e=await Fe.sha256(r);return ue(e)}static updatableSha256(){return Fe.updatableSha256()}static async generateAuthorKeypair(r){bt.debug(`generateAuthorKeypair("${r}")`);let e=await Fe.generateKeypairBytes(),t={address:Kt(r,ue(e.pubkey)),secret:ue(e.secret)},n=Je(t.address);return w(n)?n:t}static async generateShareKeypair(r){bt.debug(`generateAuthorKeypair("${r}")`);let e=await Fe.generateKeypairBytes(),t={shareAddress:Wt(r,ue(e.pubkey)),secret:ue(e.secret)},n=X(t.shareAddress);return w(n)?n:t}static async sign(r,e){bt.debug("sign");try{let t=Un(r);if(w(t))return t;let n=await Fe.sign(t,e);return ue(n)}catch(t){return new f("unexpected error while signing: "+t.message)}}static verify(r,e,t){bt.debug("verify");try{let n=gt(r);return w(n)?Promise.resolve(!1):Fe.verify(Ze(n.pubkey),Ze(e),t)}catch{return Promise.resolve(!1)}}static async checkKeypairIsValid(r){bt.debug("checkAuthorKeypairIsValid");let e=Fr(r)?r.address:r.shareAddress;try{if(typeof e!="string"||typeof r.secret!="string")return new f("address and secret must be strings");let t=gt(e);if(w(t))return t;let n="a test message to sign. "+re(),s=await this.sign(r,n);return w(s)?s:await this.verify(e,s,n)===!1?new f("pubkey does not match secret"):!0}catch(t){return new f("unexpected error in checkAuthorKeypairIsValid: "+t.message)}}};var Sc=new R("validator es.4","red"),Si=10,Di=Si*60*1e3*1e3,Vn=1e13,qn=9007199254740990,xi=4e6,Ei=53,Ii=104,Kn={objSchema:{format:$t("es.4"),author:z({allowedChars:Ut}),content:z({maxLen:xi}),contentHash:z({allowedChars:le,len:Ei}),deleteAfter:qe({min:Vn,max:qn,nullable:!0}),path:z({allowedChars:qt,minLen:2,maxLen:512}),signature:z({allowedChars:le,len:Ii}),timestamp:qe({min:Vn,max:qn}),workspace:z({allowedChars:Vt})},allowLiteralUndefined:!1,allowExtraKeys:!1},Lr,Dc=(Lr=class{static hashDocument(r){let e={...r,signature:"bthisisafakesignatureusedtofillintheobjectwhenvalidatingitforhashingaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"},t=this._checkBasicDocumentValidity(e);return w(t)?Promise.resolve(t):F.sha256base32(`author	${r.author}
contentHash	${r.contentHash}
`+(r.deleteAfter===null?"":`deleteAfter	${r.deleteAfter}
`)+`format	${r.format}
path	${r.path}
timestamp	${r.timestamp}
workspace	${r.workspace}
`)}static async generateDocument({input:r,keypair:e,share:t,timestamp:n}){let s={format:"es.4",author:e.address,content:r.content,contentHash:await F.sha256base32(r.content),deleteAfter:r.deleteAfter??null,path:r.path,timestamp:n,workspace:t,signature:"?"},i=await this.signDocument(e,s);return w(i)?i:{doc:i}}static async signDocument(r,e){let t=await this.hashDocument(e);if(w(t))return t;let n=await F.sign(r,t);return w(n)?n:{...e,signature:n}}static async wipeDocument(r,e){if(e.content.length===0)return e;let t=this.removeExtraFields(e);if(w(t))return t;let s={...t.doc,content:"",contentHash:await F.sha256base32(""),signature:"?"};return this.signDocument(r,s)}static removeExtraFields(r){if(!Ye(r))return new f("doc is not a plain javascript object");let e=new Set(Object.keys(Kn.objSchema||{})),t={},n={};for(let[s,i]of Object.entries(r))if(e.has(s))t[s]=i;else{if(!s.startsWith("_"))return new f("extra document fields must have names starting with an underscore");n[s]=i}return{doc:t,extras:n}}static async checkDocumentIsValid(r,e){e===void 0&&(e=Date.now()*1e3);let t=this._checkBasicDocumentValidity(r);if(w(t))return t;let n=this._checkTimestampIsOk(r.timestamp,r.deleteAfter,e);if(w(n))return n;let s=this._checkAuthorCanWriteToPath(r.author,r.path);if(w(s))return s;let i=this._checkPathIsValid(r.path,r.deleteAfter);if(w(i))return i;let a=Je(r.author);if(w(a))return a;let o=X(r.workspace);if(w(o))return o;let c=await this._checkAuthorSignatureIsValid(r);if(w(c))return c;let l=await this._checkContentMatchesHash(r.content,r.contentHash);return w(l)?l:!0}static _checkBasicDocumentValidity(r){let e=Qt(Kn)(r);return e!==null?new f(e):!0}static _checkAuthorCanWriteToPath(r,e){return e.indexOf("~")===-1||e.indexOf("~"+r)!==-1?!0:new f(`author ${r} can't write to path ${e}`)}static _checkTimestampIsOk(r,e,t){if(r>t+Di)return new f("timestamp too far in the future");if(e!==null){if(t>e)return new f("ephemeral doc has expired");if(e<=r)return new f("ephemeral doc expired before it was created")}return!0}static _checkPathIsValid(r,e){if(!r.startsWith("/"))return new f("invalid path: must start with /");if(r.endsWith("/"))return new f("invalid path: must not end with /");if(r.startsWith("/@"))return new f('invalid path: must not start with "/@"');if(r.indexOf("//")!==-1)return new f("invalid path: must not contain two consecutive slashes");if(e!==void 0){if(r.indexOf("!")===-1&&e!==null)return new f("when deleteAfter is set, path must contain '!'");if(r.indexOf("!")!==-1&&e===null)return new f("when deleteAfter is null, path must not contain '!'")}return!0}static async _checkAuthorSignatureIsValid(r){try{let e=await this.hashDocument(r);return w(e)?e:await F.verify(r.author,r.signature,e)!==!0?new f("signature is invalid"):!0}catch{return new f("signature is invalid (unexpected exception)")}}static async _checkContentMatchesHash(r,e){return await F.sha256base32(r)!==e?new f("content does not match contentHash"):!0}static getAttachmentInfo(r){return new f("es.4 does not support attachments")}static updateAttachmentFields(r,e,t,n){return Promise.resolve(new f("es.4 does not support attachments"))}static authorFromCredentials(r){return r.address}},Lr.id="es.4",Lr);var Lc=new R("validator es.5","red"),ki=10,Bi=ki*60*1e3*1e3,Wn=1e13,$n=9007199254740990,Ri=8e3,Qn=53,jn=104,Ci=0,Pi=Number.MAX_SAFE_INTEGER,Hn={objSchema:{format:$t("es.5"),author:z({allowedChars:Ut}),text:z({maxLen:Ri}),textHash:z({allowedChars:le,len:Qn}),deleteAfter:qe({min:Wn,max:$n,optional:!0}),path:z({allowedChars:qt,minLen:2,maxLen:512}),signature:z({allowedChars:le,len:jn}),shareSignature:z({allowedChars:le,len:jn}),timestamp:qe({min:Wn,max:$n}),share:z({allowedChars:Vt}),attachmentSize:qe({min:Ci,max:Pi,optional:!0}),attachmentHash:z({allowedChars:le,len:Qn,optional:!0})},allowLiteralUndefined:!1,allowExtraKeys:!1},Mr,Gn=(Mr=class{static hashDocument(r){let e={...r,signature:"bthisisafakesignatureusedtofillintheobjectwhenvalidatingitforhashingaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",shareSignature:"bthisisafakesignatureusedtofillintheobjectwhenvalidatingitforhashingaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"},t=this._checkBasicDocumentValidity(e);return w(t)?Promise.resolve(t):F.sha256base32((r.attachmentHash===void 0?"":`attachmentHash	${r.attachmentHash}
`)+(r.attachmentSize===void 0?"":`attachmentSize	${r.attachmentSize}
`)+`author	${r.author}
`+(r.deleteAfter===void 0?"":`deleteAfter	${r.deleteAfter}
`)+`format	${r.format}
path	${r.path}
textHash	${r.textHash}
timestamp	${r.timestamp}
share	${r.share}
`)}static async generateDocument({input:r,keypair:e,share:t,timestamp:n,prevLatestDoc:s,config:i}){if(r.text===void 0&&s?.text===void 0)return new f("Couldn't determine document text from given input or previous version's text.");let a=r.text!==void 0?r.text:s?.text,o={...s,format:"es.5",author:e.address,text:a,textHash:await F.sha256base32(a),path:r.path,timestamp:n,share:t,signature:"?",shareSignature:"?"};r.deleteAfter&&(o.deleteAfter=r.deleteAfter);let c=await this.signDocument(e,o,i);return w(c)?c:r.attachment?{doc:c,attachment:r.attachment}:{doc:c}}static async signDocument(r,e,t){let n=await this.hashDocument(e);if(w(n))return n;let s=await F.sign(r,n);if(t.shareSecret===void 0)return new P(`Tried to write a document to ${e.share} without the secret.`);let i=await F.sign({shareAddress:e.share,secret:t.shareSecret},n);return w(s)?s:w(i)?i:{...e,signature:s,shareSignature:i}}static async wipeDocument(r,e,t){if(e.text.length===0)return e;let n=this.removeExtraFields(e);if(w(n))return n;let s=n.doc;if(s.attachmentHash){let a={...s,text:"",textHash:await F.sha256base32(""),signature:"?",shareSignature:"?",attachmentHash:await F.sha256base32(""),attachmentSize:0};return this.signDocument(r,a,t)}let i={...s,text:"",textHash:await F.sha256base32(""),signature:"?",shareSignature:"?"};return this.signDocument(r,i,t)}static removeExtraFields(r){if(!Ye(r))return new f("doc is not a plain javascript object");let e=new Set(Object.keys(Hn.objSchema||{})),t={},n={};for(let[s,i]of Object.entries(r))if(e.has(s))t[s]=i;else{if(!s.startsWith("_"))return new f("extra document fields must have names starting with an underscore");n[s]=i}return{doc:t,extras:n}}static async checkDocumentIsValid(r,e){e===void 0&&(e=Date.now()*1e3);let t=this._checkBasicDocumentValidity(r);if(w(t))return t;let n=this._checkTimestampIsOk(r.timestamp,r.deleteAfter?r.deleteAfter:null,e);if(w(n))return n;let s=this._checkAuthorCanWriteToPath(r.author,r.path);if(w(s))return s;let i=this._checkAttachmentFieldsConsistent(r);if(w(i))return i;let a=this._checkPathIsValid(r.path,!!r.attachmentHash,r.deleteAfter);if(w(a))return a;let o=Je(r.author);if(w(o))return o;let c=X(r.share);if(w(c))return c;let l=await this._checkAuthorSignatureIsValid(r);if(w(l))return l;let h=await this._checkShareSignatureIsValid(r);if(w(h))return h;let d=await this._checkContentMatchesHash(r.text,r.textHash);return w(d)?d:!0}static _checkBasicDocumentValidity(r){let e=Qt(Hn)(r);return e!==null?new f(e):!0}static _checkAttachmentFieldsConsistent(r){return r.text.length===0&&r.attachmentSize&&r.attachmentSize>0?new f("Documents with attachments must have text."):(r.text.length>0&&r.attachmentSize&&r.attachmentSize,r.attachmentHash&&r.attachmentSize===void 0?new f("Attachment size is undefined while attachment hash is defined"):r.attachmentSize&&r.attachmentHash===void 0?new f("Attachment hash is undefined while attachment size is defined"):!0)}static _checkAuthorCanWriteToPath(r,e){return e.indexOf("~")===-1||e.indexOf("~"+r)!==-1?!0:new f(`author ${r} can't write to path ${e}`)}static _checkTimestampIsOk(r,e,t){if(r>t+Bi)return new f("timestamp too far in the future");if(e!==null){if(t>e)return new f("ephemeral doc has expired");if(e<=r)return new f("ephemeral doc expired before it was created")}return!0}static _checkPathIsValid(r,e,t){if(!r.startsWith("/"))return new f("invalid path: must start with /");if(r.endsWith("/"))return new f("invalid path: must not end with /");if(r.startsWith("/@"))return new f('invalid path: must not start with "/@"');if(r.indexOf("//")!==-1)return new f("invalid path: must not contain two consecutive slashes");if(t!==void 0){if(r.indexOf("!")===-1&&t!==null)return new f("when deleteAfter is set, path must contain '!'");if(r.indexOf("!")!==-1&&t===null)return new f("when deleteAfter is null, path must not contain '!'")}return!zn(r)&&e?new f("when a attachment is provided, the path must end with a file extension"):zn(r)&&e===!1?new f("when no attachment is provided, the path cannot end with a file extension"):!0}static async _checkAuthorSignatureIsValid(r){try{let e=await this.hashDocument(r);return w(e)?e:await F.verify(r.author,r.signature,e)!==!0?new f("signature is invalid"):!0}catch{return new f("signature is invalid (unexpected exception)")}}static async _checkShareSignatureIsValid(r){try{let e=await this.hashDocument(r);return w(e)?e:await F.verify(r.share,r.shareSignature,e)!==!0?new f("share signature is invalid"):!0}catch{return new f("share signature is invalid (unexpected exception)")}}static async _checkContentMatchesHash(r,e){return await F.sha256base32(r)!==e?new f("content does not match contentHash"):!0}static getAttachmentInfo(r){return r.attachmentHash&&r.attachmentSize===0?new f("This document has had its attachment wiped"):!r.attachmentHash||!r.attachmentSize?new f("This document has no attachment."):{size:r.attachmentSize,hash:r.attachmentHash}}static updateAttachmentFields(r,e,t,n,s){let i={...e,attachmentHash:n,attachmentSize:t};return this.signDocument(r,i,s)}static authorFromCredentials(r){return r.address}},Mr.id="es.5",Mr),Fi=/^.*\.(\w+)$/,Li=/^.*~@\w{4}\.\w{53}$/;function zn(r){if(r.indexOf(".")===-1)return!1;let e=r.match(Fi);return!(e===null||e[1].length===53&&r.match(Li))}var se=Gn,Xe=[se];function _r(r){return r||se}function Ee(r){return r||Xe}function Jn(r,e){let t=[];for(let n of e)r.includes(n.id)&&t.push(n);return t}function ve(r){let e=r||Xe,t={};for(let n of e)t[n.id]=n;return t}var Ae=class{constructor(){this.deferreds=new Set;this.state="pending"}resolve(e){if(this.state==="pending"){this.state="fulfilled";for(let t of this.deferreds)t.resolve(e)}}reject(e){if(this.state==="pending"){this.state="rejected";for(let t of this.deferreds)t.reject(e)}}getPromise(){let e=T();return this.state==="fulfilled"?e.resolve():this.state==="rejected"?e.reject():this.deferreds.add(e),e}};var fe=class{constructor(e=!1){this.promises=new Set;this.sealed=!1;this.multiDeferred=new Ae;this.allowRejectedPromises=e}enrol(e){if(this.sealed)throw new P("Tried to enrol a promise when enrolment was already sealed.");this.promises.add(e),e.then(()=>{this.checkAllDone()}).catch(t=>{if(!this.allowRejectedPromises)throw t})}checkAllDone(){this.sealed&&(this.allowRejectedPromises?Promise.allSettled(this.promises).then(()=>{this.multiDeferred.resolve()}):Promise.all(this.promises).then(()=>{this.multiDeferred.resolve()}).catch(()=>{this.multiDeferred.reject()}))}seal(){this.sealed||(this.sealed=!0,this.checkAllDone())}isSealed(){return this.sealed}isDone(){return this.multiDeferred.getPromise()}};var Nr=class{constructor(){this.closed=!1;this.transform=new TransformStream({transform(e,t){t.enqueue(e)}});this.writer=this.transform.writable.getWriter();this.readable=this.transform.readable;this.writables=[]}checkClosed(){if(this.closed)throw"Closed"}getWritableStream(){this.checkClosed();let e=this.writer,t=new WritableStream({async write(n){await e.ready,await e.write(n)}});return this.writables.push(t),t}async close(){this.checkClosed();for(let e of this.writables)await e.abort();this.transform.writable.abort(),this.closed=!0}isClosed(){return this.closed}},Ur=class{constructor(){this.transformStream=new TransformStream(new qr);this.sourceReadable=this.transformStream.readable;this.writable=this.transformStream.writable}getReadableStream(){let[e,t]=this.sourceReadable.tee();return this.sourceReadable=e,t}},Or=class{constructor(){this.closed=!1;this.subscribers=[];this.writables=[];let e=this.subscribers;this.writable=new WritableStream({write(t){let n=e.map(({writer:s})=>new Promise(i=>{s.ready.then(()=>{s.write(t).then(i)})}));Promise.all(n)}})}checkClosed(){if(this.closed)throw"Closed"}getReadableStream(){this.checkClosed();let e=new TransformStream({transform(t,n){n.enqueue(t)}});return this.subscribers.push({transform:e,writer:e.writable.getWriter()}),e.readable}async close(){this.checkClosed();for(let e of this.writables)await e.abort();for(let{transform:e}of this.subscribers)await e.writable.abort(),await e.readable.cancel();this.closed=!0}isClosed(){return this.closed}},Vr=class{constructor(e){this.closed=!1;this.combineStream=new Nr;e?this.cloneStream=new Or:this.cloneStream=new Ur,this.combineStream.readable.pipeTo(this.cloneStream.writable)}checkClosed(){if(this.closed)throw"Closed"}getWritableStream(){return this.combineStream.getWritableStream()}getReadableStream(){return this.cloneStream.getReadableStream()}close(){this.checkClosed(),this.combineStream.close(),this.closed=!0}isClosed(){return this.closed}},et=class{constructor(){this.callbacks=new Set}onWrite(e){return this.callbacks.add(e),()=>{this.callbacks.delete(e)}}async write(e){for(let t of this.callbacks)await t(e)}close(){this.callbacks.clear()}},G=class{constructor(){this.callbacks=new Set;this.lock=new Tt}on(e){return this.callbacks.add(e),()=>{this.callbacks.delete(e)}}async send(e){for(let t of this.callbacks)await this.lock.run(()=>t(e))}},qr=class{transform(e,t){t.enqueue(e)}},Tt=class{constructor(){this.doneEnroller=new fe;this.writable=new WritableStream({async write(e){await e()}});this.writer=this.writable.getWriter();this.closed=!1}checkClosed(){if(this.closed)throw"Closed"}async run(e){this.checkClosed(),await this.writer.ready;let t=this.writer.write(e);return this.doneEnroller.enrol(t),t}async close(){this.checkClosed(),this.doneEnroller.seal(),await this.doneEnroller.isDone(),this.writer.releaseLock(),await this.writable.abort(),this.closed=!0}isClosed(){return this.closed}},Kr=class{constructor(e,t){this.channel=e,this.channelKey=t}transform(e,t){if(this.channel==="*"||this.channel===e[this.channelKey]){t.enqueue(e);return}}},zt=class{constructor(e,t){this.multistream=new Vr(t),this.channelKey=e}getWritableStream(){return this.multistream.getWritableStream()}getReadableStream(e){let t=new TransformStream(new Kr(e,this.channelKey));return this.multistream.getReadableStream().pipeThrough(t)}};function Gt(r,e){let t=T(),n=T(),s=()=>{if(n.state==="pending"){let i;r instanceof WebSocket?i=r:i=new WebSocket(r),n.resolve(i),i.binaryType="arraybuffer",i.readyState===i.OPEN&&t.resolve(),i.onopen=()=>{t.resolve()}}};return new WritableStream({async write(i,a){s();let o=await n;await t;try{let c=e(i);o.send(c)}catch(c){a.error(c)}o.onclose=()=>{a.error("Socket closed before we were done")}},async close(){s();let i=await n;await t,i.close()},async abort(){s();let i=await n;await t,i.close()}})}function Jt(r,e){let t=T(),n=!1,s=()=>{if(t.state==="pending")if(r instanceof WebSocket)t.resolve(r);else try{let i=new WebSocket(r);t.resolve(i)}catch(i){t.reject(i)}};return new ReadableStream({async start(i){s();let a=await t;a.binaryType="arraybuffer",a.onmessage=o=>{let c=e(o);try{i.enqueue(c)}catch{}},a.onclose=()=>{if(!n)try{i.close()}catch{}},a.onerror=o=>{n=!0,i.error(o)}},async cancel(){s(),(await t).close()}})}function Yn(r){let t=r.toString(16);return t.length%2&&(t="0"+t),t}function Zn(r){return BigInt("0x"+r)}var Mi={EMPTY_SET:"emptySet",LOWER_BOUND:"lowerBound",PAYLOAD:"payload",EMPTY_PAYLOAD:"emptyPayload",DONE:"done",FINGERPRINT:"fingerprint",TERMINAL:"terminal"},_i={encode:{emptySet:r=>({type:"EMPTY_SET",canRespond:r}),lowerBound:r=>({type:"LOWER_BOUND",value:r}),payload:(r,e)=>({type:"PAYLOAD",payload:r,...e?{end:e}:{}}),emptyPayload:r=>({type:"EMPTY_PAYLOAD",upperBound:r}),done:r=>({type:"DONE",upperBound:r}),fingerprint:(r,e)=>({type:"FINGERPRINT",fingerprint:Yn(r),upperBound:e}),terminal:()=>({type:"TERMINAL"})},decode:{getType:r=>Mi[r.type],emptySet:r=>{if(r.type==="EMPTY_SET")return r.canRespond;throw"Can't decode"},lowerBound:r=>{if(r.type==="LOWER_BOUND")return r.value;throw"Can't decode"},payload:r=>{if(r.type==="PAYLOAD")return{value:r.payload,...r.end?{end:r.end}:{}};throw"Can't decode"},emptyPayload:r=>{if(r.type==="EMPTY_PAYLOAD")return r.upperBound;throw"Can't decode"},done:r=>{if(r.type==="DONE")return r.upperBound;throw"Can't decode"},fingerprint:r=>{if(r.type==="FINGERPRINT")return{fingerprint:Zn(r.fingerprint),upperBound:r.upperBound};throw"Can't decode"},terminal:r=>{if(r.type==="TERMINAL")return!0;throw"Can't decode"}}},Yt=class extends ft{constructor(e,t,n){super({tree:e,encoding:_i,fingerprintEquals:(s,i)=>s===i,payloadThreshold:t,rangeDivision:n})}};var Zt=class{constructor(e){this.statusBus=new G;this.isDoneMultiDeferred=new Ae;this.inboundEventQueue=new j;this.outboundEventQueue=new j;this.gossiperInboundQueue=new j;this.reconcilerInboundQueue=new j;this.hasPrepared=T();this.hasReconciled=T();this.hasCheckedAllExistingDocsForAttachments=T();this.requestedCount=0;this.sentDocsCount=0;this.receivedDocsCount=0;this.counterpartId=re();this.replica=e.replica,e.replica.onEvent(o=>{o.kind==="willClose"&&this.cancel()});let{treeIsReady:t}=e.syncerManager.getDocThumbnailTreeAndDocLookup(e.replica.share,Ee(e.formats));t.then(()=>{this.hasPrepared.resolve()}),(async()=>{for await(let o of this.inboundEventQueue)switch(o.kind){case"RANGE_MSG":{this.reconcilerInboundQueue.push(o.message);break}default:this.gossiperInboundQueue.push(o)}})();let n=new Qr({outboundEventQueue:this.outboundEventQueue,formats:e.formats,replica:e.replica,counterpartId:this.counterpartId,transferManager:e.transferManager,hasCheckedAllExistingDocsForAttachments:this.hasCheckedAllExistingDocsForAttachments}),s=new jr,i=new $r({inboundEventQueue:this.reconcilerInboundQueue,outboundEventQueue:this.outboundEventQueue,syncerManager:e.syncerManager,formats:e.formats,replica:e.replica,initiateMessaging:e.initiateMessaging,wantTracker:s,payloadThreshold:e.payloadThreshold,rangeDivision:e.rangeDivision,onDocRequested:async()=>{this.requestedCount++,await this.statusBus.send(this.getStatus())}});i.isDone.then(()=>{this.hasReconciled.resolve()}),new Wr({inboundEventQueue:this.gossiperInboundQueue,outboundEventQueue:this.outboundEventQueue,syncerManager:e.syncerManager,formats:e.formats,replica:e.replica,counterpartId:this.counterpartId,transferManager:e.transferManager,cancel:this.cancel.bind(this),reconciliationIsDone:i.isDone,wantTracker:s,syncAppetite:e.syncAppetite,onDocReceived:async()=>{this.receivedDocsCount++,await this.statusBus.send(this.getStatus())},onDocSent:async()=>{this.sentDocsCount++,await this.statusBus.send(this.getStatus())},onDocRequested:async()=>{this.requestedCount++,await this.statusBus.send(this.getStatus())}}).isDone.then(async()=>{await this.hasCheckedAllExistingDocsForAttachments,this.isDoneMultiDeferred.resolve()}),this.statusBus.send(this.getStatus())}sendEvent(e){return this.inboundEventQueue.push(e)}events(){return this.outboundEventQueue}getStatus(){return{requestedCount:this.requestedCount,receivedCount:this.receivedDocsCount,sentCount:this.sentDocsCount,status:this.isDoneMultiDeferred.state==="rejected"?"aborted":this.hasPrepared.state==="pending"?"preparing":this.hasReconciled.state==="pending"?"reconciling":this.isDoneMultiDeferred.state==="fulfilled"?"done":"gossiping"}}onStatusUpdate(e){return this.statusBus.on(e)}async cancel(e){this.isDoneMultiDeferred.state==="fulfilled"||this.isDoneMultiDeferred.state==="rejected"||(this.isDoneMultiDeferred.reject(e||"Cancelled"),await this.statusBus.send(this.getStatus()),this.outboundEventQueue.push({kind:"ABORT"}),this.outboundEventQueue.close(),this.inboundEventQueue.close({immediately:!0}),this.gossiperInboundQueue.close({immediately:!0}),this.reconcilerInboundQueue.close({immediately:!0}))}isDone(){return this.isDoneMultiDeferred.getPromise()}},Wr=class{constructor(e){this.isPartnerFulfilled=T();this.isFulfilled=T();let t=ve(e.formats),n=e.syncerManager.getPlumTree(e.replica.share);if(e.syncAppetite==="continuous"){let a=e.replica.getQueryStream(void 0,"new",e.formats),o=new Ce;a.pipeTo(new WritableStream({async write(c){if(c.kind==="success"&&c.sourceId!==e.counterpartId){let l=n.getMode(c.sourceId);o.reset(),o.update(`${c.doc.path} ${c.doc.author}`);let h=o.digest().toString(16),d=`${c.doc.timestamp} ${h}`;if(l==="EAGER"){let u=t[c.doc.format],p=u.getAttachmentInfo(c.doc),m=!w(p),g=!1;m&&await e.replica.getAttachment(c.doc,u)&&(g=!0),e.outboundEventQueue.push({kind:"DOC",thumbnail:d,doc:c.doc,attachmentHeld:g}),e.onDocSent()}else e.outboundEventQueue.push({kind:"HAVE",thumbnail:d})}}})).catch(()=>{})}let s=e.replica.onEvent(a=>{a.kind==="attachment_ingest"&&a.sourceId!==e.counterpartId&&e.outboundEventQueue.push({kind:"NEW_ATTACHMENT",path:a.doc.path,author:a.doc.author,format:a.doc.format,hash:a.hash})}),{lookup:i}=e.syncerManager.getDocThumbnailTreeAndDocLookup(e.replica.share,Ee(e.formats));(async()=>{for await(let a of e.inboundEventQueue)switch(a.kind){case"PRUNE":{n.onPrune(e.counterpartId);break}case"HAVE":{if(e.reconciliationIsDone.state==="fulfilled"&&e.syncAppetite==="once")break;e.wantTracker.addWantedThumbnail(a.thumbnail),n.onLazyMessage(a,o=>{e.outboundEventQueue.push({kind:"WANT",thumbnail:o})}),e.onDocRequested();break}case"WANT":{n.onGraftMessage(e.counterpartId);let[,o]=a.thumbnail.split(" "),c=i[o];if(!c)return;let[,l,h]=c,u=(await e.replica.getAllDocsAtPath(l,e.formats)).find(p=>p.author===h);if(u){let p=t[u.format],m=p.getAttachmentInfo(u),g=!w(m),v=!1;g&&await e.replica.getAttachment(u,p)&&(v=!0),e.outboundEventQueue.push({kind:"DOC",thumbnail:a.thumbnail,doc:u,attachmentHeld:v}),await e.onDocSent()}else console.error("Got a WANT event for a document not on record.");break}case"DOC":{if(this.isFulfilled.state==="fulfilled"&&e.syncAppetite==="once"||(n.onEagerMessage(e.counterpartId,a)&&e.outboundEventQueue.push({kind:"PRUNE"}),e.wantTracker.isReceived(a.thumbnail)))break;let c=t[a.doc.format];if(!c){console.error(`Was sent a doc with a format we don't know about (${a.doc.format})`);break}if(a.attachmentHeld&&await e.replica.getAttachment(a.doc,t[a.doc.format])===void 0){let h=await e.transferManager.handleDownload(a.doc,e.replica,e.counterpartId);if(w(h)){let d=c.getAttachmentInfo(a.doc);e.transferManager.registerExpectedTransfer(e.replica.share,d.hash),e.outboundEventQueue.push({kind:"WANT_ATTACHMENT",attachmentHash:d.hash,doc:a.doc,shareAddress:e.replica.share})}}await e.replica.ingest(c,a.doc,e.counterpartId),e.wantTracker.receivedWantedThumbnail(a.thumbnail),await e.onDocReceived();break}case"NEW_ATTACHMENT":{if(e.transferManager.isAlreadyQueued(a.hash,"download"))break;let o=t[a.format],l=(await e.replica.getAllDocsAtPath(a.path,[o])).find(d=>a.author===d.author);if(!l)break;if(await e.replica.getAttachment(l,t[l.format])===void 0){let d=await e.transferManager.handleDownload(l,e.replica,e.counterpartId);if(w(d)){let u=o.getAttachmentInfo(l);e.transferManager.registerExpectedTransfer(e.replica.share,u.hash),e.outboundEventQueue.push({kind:"WANT_ATTACHMENT",attachmentHash:u.hash,doc:l,shareAddress:e.replica.share})}}break}case"FULFILLED":this.isPartnerFulfilled.resolve(!0);break;case"WANT_ATTACHMENT":e.transferManager.handleUpload(a,e.replica);break;case"ABORT":await e.cancel()}})(),e.reconciliationIsDone.then(async()=>{e.syncAppetite==="once"&&(s(),e.wantTracker.seal(),await e.wantTracker.isDone(),e.outboundEventQueue.push({kind:"FULFILLED"}),this.isFulfilled.resolve())})}get isDone(){return Promise.all([this.isPartnerFulfilled,this.isFulfilled])}},$r=class{constructor(e){this.communicationRoundsCount=0;this.isDone=T();let{tree:t,lookup:n,treeIsReady:s}=e.syncerManager.getDocThumbnailTreeAndDocLookup(e.replica.share,Ee(e.formats));e.initiateMessaging&&s.then(()=>{for(let a of i.initialMessages())e.outboundEventQueue.push({kind:"RANGE_MSG",message:a})});let i=new Yt(t,e.payloadThreshold,e.rangeDivision);i.onInsertion(a=>{let[o,c]=a.split(" "),l=n[c];l&&l[0]>=parseInt(o)||(e.wantTracker.addWantedThumbnail(a),e.outboundEventQueue.push({kind:"WANT",thumbnail:a}),e.onDocRequested())}),(async()=>{await s;for await(let a of e.inboundEventQueue){if(this.isDone.state==="fulfilled")return;a.type==="TERMINAL"&&this.communicationRoundsCount++;let o=i.respond(a);for(let c of o)e.outboundEventQueue.push({kind:"RANGE_MSG",message:c})}})(),i.isDone().then(()=>{this.isDone.resolve(this.communicationRoundsCount)})}},Qr=class{constructor(e){let t=e.replica.getQueryStream({orderBy:"localIndex ASC"},"existing",e.formats),n=ve(e.formats),s=e.transferManager.handleDownload.bind(e.transferManager);t.pipeTo(new WritableStream({start(i){e.replica.onEvent(a=>{a.kind==="willClose"&&i.error()})},async write(i){if(i.kind==="existing"||i.kind==="success"){let a=n[i.doc.format],o=await e.replica.getAttachment(i.doc,a);if(w(o))return;if(o===void 0){let c=await s(i.doc,e.replica,e.counterpartId);if(w(c)){let l=a.getAttachmentInfo(i.doc);e.transferManager.registerExpectedTransfer(e.replica.share,l.hash),e.outboundEventQueue.push({kind:"WANT_ATTACHMENT",attachmentHash:l.hash,doc:i.doc,shareAddress:e.replica.share})}}}}})).then(()=>{e.hasCheckedAllExistingDocsForAttachments.resolve()}).catch(()=>{e.hasCheckedAllExistingDocsForAttachments.resolve()})}},jr=class{constructor(){this.isSealed=!1;this.wantedThumbnails=new Map;this.enroller=new fe;this.received=0;this.id=re()}addWantedThumbnail(e){if(!this.isSealed&&!this.wantedThumbnails.has(e)){let t=T();this.wantedThumbnails.set(e,t),this.enroller.enrol(t)}}receivedWantedThumbnail(e){let t=this.wantedThumbnails.get(e);t&&(t.resolve(),this.received++)}isRequested(e){return this.wantedThumbnails.has(e)}isReceived(e){let t=this.wantedThumbnails.get(e);return t?t.state==="fulfilled":!1}seal(){this.enroller.seal()}isDone(){return this.enroller.isDone()}get requestedCount(){return this.wantedThumbnails.size}get receivedCount(){return this.received}};var tt=class{constructor(e,t){this.closed=!1;this.cb=e,this.ms=t,this.timeout=setTimeout(e,t)}bump(){this.closed||(clearTimeout(this.timeout),this.timeout=setTimeout(this.cb,this.ms))}close(){this.closed=!0,clearTimeout(this.timeout)}};var rt=class{constructor({stream:e,replica:t,doc:n,format:s,requester:i,counterpartId:a}){this.status="ready";this.loaded=0;this.statusBus=new G;this.transferOp=T();this.multiDeferred=new Ae;this.sourceDoc=n,this.share=t.share,this.requester=i;let o=s.getAttachmentInfo(n);if(w(o))throw new f("AttachmentTransfer was given a doc which has no attachment!");this.hash=o.hash,this.expectedSize=o.size;let c=this.updateLoaded.bind(this);if(e instanceof ReadableStream){this.kind="download";let l;this.abortCb=()=>{l?l.cancel():e.cancel()};let h=()=>this.loaded,d=()=>new ReadableStream({async start(u){let p=e.getReader();l=p;let m=new tt(()=>{u.error("Attachment download timed out.")},1e4);for(;;){let{done:g,value:v}=await p.read();if(m.bump(),g||(c(v.byteLength),u.enqueue(v),h()>=o.size))break}m.close(),u.close()}});this.transferOp.resolve(()=>{let u=T();return t.ingestAttachment(s,n,d(),a).then(p=>{if(w(p)&&this.loaded===0){this.changeStatus("missing_attachment");return}if(w(p)){console.warn(`Couldn't ingest the attachment for ${n.path} by ${n.author}: ${p.message}`),u.reject(p);return}u.resolve()}).catch(p=>{console.log(p),u.reject(p)}),u})}else this.kind="upload",this.abortCb=()=>{e.abort().catch(()=>{})},t.getAttachment(n,s).then(async l=>{if(!l){await this.changeStatus("missing_attachment"),await e.abort();return}if(w(l)){await this.changeStatus("failed"),await e.abort();return}let h=new TransformStream({transform(d,u){c(d.byteLength),u.enqueue(d)}});this.transferOp.resolve(()=>l.stream().then(d=>d.pipeThrough(h).pipeTo(e)).catch(d=>{console.log(d)}))})}async start(){if(this.status!=="ready")return;let e=await this.transferOp;await this.changeStatus("in_progress"),e().then(async()=>{await this.changeStatus("complete")}).catch(async()=>{await this.changeStatus("failed")})}updateLoaded(e){this.loaded+=e,this.statusBus.send({status:this.status,bytesLoaded:this.loaded,totalBytes:this.expectedSize})}async changeStatus(e){this.status==="complete"||this.status==="failed"||this.status==="missing_attachment"||(this.status=e,await this.statusBus.send({status:e,bytesLoaded:this.loaded,totalBytes:this.expectedSize}),e==="complete"&&this.multiDeferred.resolve(),e==="failed"&&this.multiDeferred.reject("Attachment transfer failed"),e==="missing_attachment"&&this.multiDeferred.reject("The other peer does not have this attachment"))}get doc(){return this.sourceDoc}onProgress(e){return this.statusBus.on(e)}abort(){this.abortCb()}isDone(){return this.multiDeferred.getPromise()}};var Xt=class{constructor(e){this.waiting=[];this.active=new Set;this.failed=new Set;this.completed=new Set;this.transfersRequestedByUsEnroller=new fe(!0);this.closed=!1;this.reports={};this.reportBus=new G;this.activeLimit=e}async activate(e){this.active.add(e),e.isDone().then(()=>{this.completed.add(e)}).catch(()=>{this.failed.add(e)}).finally(()=>{this.active.delete(e),this.admitNext()}),await e.start()}queue(e){this.waiting.push(e)}admitNext(){if(this.waiting.length===0||this.active.size>=this.activeLimit)return;let e=this.waiting.shift();e&&this.activate(e)}async addTransfer(e){if(this.closed){e.abort();return}e.onProgress(()=>{this.updateTransferStatus(e)}),e.requester==="us"&&this.transfersRequestedByUsEnroller.enrol(e.isDone()),this.active.size<this.activeLimit?await this.activate(e):this.queue(e)}gotAllTransfersRequestedByUs(){this.transfersRequestedByUsEnroller.seal()}cancel(){this.closed=!0,this.transfersRequestedByUsEnroller.seal();for(let e of this.active)e.abort()}updateTransferStatus(e){this.reports[e.share]||(this.reports[e.share]={}),this.reports[e.share][e.hash+e.kind]={author:e.doc.author,path:e.doc.path,format:e.doc.format,hash:e.hash,kind:e.kind,status:e.status,bytesLoaded:e.loaded,totalBytes:e.expectedSize},this.reportBus.send(this.getReport())}getReport(){let e={};for(let t in this.reports){let n=[],s=this.reports[t];for(let i in s){let a=s[i];n.push(a)}e[t]=n}return e}hasQueuedTransfer(e,t){for(let n of this.waiting)if(n.hash===e&&n.kind===t)return!0;for(let n of this.active)if(n.hash===e&&n.kind===t)return!0;for(let n of this.completed)if(n.hash===e&&n.kind===t)return!0;return!1}onReportUpdate(e){return this.reportBus.on(e)}transfersRequestedByUsFinished(){return this.transfersRequestedByUsEnroller.isDone()}};var er=class{constructor(e){this.otherSyncerId=T();this.receivedAllExpectedTransfersEnroller=new fe;this.madeAllAttachmentRequestsEnroller=new fe(!0);this.reportDidUpdateBus=new G;this.expectedTransferPromises=new Map;this.partner=e.partner,this.queue=new Xt(this.partner.concurrentTransfers),this.formats=e.formats,this.formatsLookup=ve(this.formats),this.queue.onReportUpdate(async t=>{await this.reportDidUpdateBus.send(t)}),this.madeAllAttachmentRequestsEnroller.isDone().then(()=>{this.receivedAllExpectedTransfersEnroller.seal()}),this.receivedAllExpectedTransfersEnroller.isDone().then(()=>{this.queue.gotAllTransfersRequestedByUs()})}registerSyncAgent(e){this.madeAllAttachmentRequestsEnroller.enrol(e.isDone())}allSyncAgentsKnown(){this.madeAllAttachmentRequestsEnroller.seal()}registerExpectedTransfer(e,t){let n=`${e}_${t}`;if(this.expectedTransferPromises.has(n))return;let s=T();this.expectedTransferPromises.set(n,s),this.receivedAllExpectedTransfersEnroller.enrol(s)}async queueTransfer(e){this.queue.hasQueuedTransfer(e.hash,e.kind)||await this.queue.addTransfer(e)}async handleDownload(e,t,n){let s=this.formatsLookup[e.format],i=s.getAttachmentInfo(e);if(w(i))throw new P("TransferManager: attempted to download doc with no attachment.");if(this.queue.hasQueuedTransfer(i.hash,"download"))return"queued";let a=await this.partner.getDownload({doc:e,shareAddress:t.share,syncerId:await this.otherSyncerId,attachmentHash:i.hash});if(a===void 0)return"no_attachment";if(w(a))return a;let o=new rt({replica:t,doc:e,format:s,stream:a,requester:"us",counterpartId:n});return await this.queueTransfer(o),"queued"}async handleUpload(e,t){if(this.queue.hasQueuedTransfer(e.attachmentHash,"upload"))return!1;let n=this.formatsLookup[e.doc.format];if(!await t.getAttachment(e.doc,n))return!1;let i=await this.partner.handleUploadRequest({shareAddress:e.shareAddress,syncerId:await this.otherSyncerId,doc:e.doc,attachmentHash:e.attachmentHash});if(w(i))return!1;try{let a=new rt({doc:e.doc,format:n,replica:t,stream:i,requester:"them",counterpartId:"unused"});await this.queueTransfer(a)}catch{return!1}return!0}async handleTransferRequest({replica:e,path:t,author:n,source:s,kind:i,formatName:a,counterpartId:o}){let c=await this.partner.handleTransferRequest(s,i);if(c===void 0||w(c))return;let l=ve(this.formats)[a];if(!l)return;let d=(await e.getAllDocsAtPath(t,[l])).find(p=>p.author===n);if(!d)return;let u=new rt({doc:d,format:l,replica:e,stream:c,requester:i==="upload"?"us":"them",counterpartId:o});if(u.requester==="us"){let p=`${u.share}_${u.hash}`,m=this.expectedTransferPromises.get(p);m&&m.resolve()}await this.queueTransfer(u)}cancel(){this.queue.cancel()}getReport(){return this.queue.getReport()}onReportUpdate(e){return this.reportDidUpdateBus.on(e)}transfersRequestedByUsFinished(){return this.queue.transfersRequestedByUsFinished()}registerOtherSyncerId(e){this.otherSyncerId.resolve(e)}isAlreadyQueued(e,t){return this.queue.hasQueuedTransfer(e,t)}};var nt=class{constructor(e){this.id=re();this.syncAgents=new Map;this.syncAgentQueues=new Map;this.statusBus=new G;this.partnerIsFulfilled=T();this.isDoneMultiDeferred=new Ae;this.manager=e.manager,this.peer=e.manager.peer,this.appetite=e.partner.syncAppetite,this.formats=Ee(e.formats),this.partner=e.partner,this.transferManager=new er({partner:this.partner,formats:this.formats}),this.transferManager.onReportUpdate(async()=>{await this.statusBus.send(this.getStatus())}),this.heartbeatInterval=setInterval(()=>{this.partner.sendEvent({kind:"HEARTBEAT"})},1e3),(async()=>{try{for await(let n of e.partner.getEvents())this.handleIncomingEvent(n)}catch(n){this.cancel(n||"Partner disconnected")}})();let t=re();Promise.all(this.peer.shares().map(n=>tr(t,n))).then(n=>{this.partner.sendEvent({kind:"DISCLOSE",salt:t,syncerId:this.id,shares:n,formats:this.formats?this.formats.map(s=>s.id):[se.id],canRespond:!1})}),this.transferManager.transfersRequestedByUsFinished().then(async()=>{e.partner.syncAppetite!=="continuous"&&(await this.partner.sendEvent({kind:"SYNCER_FULFILLED"}),await this.partnerIsFulfilled,clearInterval(this.heartbeatInterval),await this.partner.closeConnection(),this.bumpingTimeout.close(),this.isDoneMultiDeferred.resolve())}),this.peer.onReplicasChange(async n=>{if(this.appetite==="once")return;let s=Array.from(n.keys());for(let[a,o]of this.syncAgents)s.includes(a)===!1&&(await o.cancel("Replica was removed from peer."),this.syncAgents.delete(a));let i=re();Promise.all(s.map(a=>tr(i,a))).then(a=>{this.partner.sendEvent({kind:"DISCLOSE",salt:i,syncerId:this.id,shares:a,formats:this.formats?this.formats.map(o=>o.id):[se.id],canRespond:!0})})}),this.bumpingTimeout=new tt(()=>{this.cancel("No communication from the other peer in the last three seconds.")},1e4)}addShare(e,t,n){if(this.syncAgents.has(e))return;let s=this.peer.getReplica(e);if(!s){console.error("Couldn't get the replica for a share we had in common.");return}let i=new Zt({replica:s,formats:t,syncerManager:this.manager,transferManager:this.transferManager,initiateMessaging:n,payloadThreshold:this.partner.payloadThreshold,rangeDivision:this.partner.rangeDivision,syncAppetite:this.appetite});i.onStatusUpdate(()=>{this.statusBus.send(this.getStatus())}),this.syncAgents.set(e,i),this.transferManager.registerSyncAgent(i);let a=this.syncAgentQueues.get(e),o;if(a)o=a;else{let c=new j;o=c,this.syncAgentQueues.set(e,c)}(async()=>{for await(let c of o)i.sendEvent(c)})(),(async()=>{for await(let c of i.events())await this.partner.sendEvent({to:e,...c})})()}async handleIncomingEvent(e){if(this.bumpingTimeout.bump(),this.isDoneMultiDeferred.state==="pending")switch(e.kind){case"DISCLOSE":{let t=Jn(e.formats,this.formats);if(t.length===0)break;let n=new Set(e.shares),s=new Set,i=new Set;for(let o of this.peer.shares()){let c=await tr(e.salt,o);n.has(c)?s.add(o):i.add(o)}let a=this.id>e.syncerId;for(let o of s)this.addShare(o,t,a);for(let o of i){let c=this.syncAgents.get(o);c&&(c.cancel("No longer in common with the other peer."),this.syncAgents.delete(o))}if(this.transferManager.registerOtherSyncerId(e.syncerId),this.appetite==="once"&&this.transferManager.allSyncAgentsKnown(),e.canRespond){let o=re();Promise.all(this.peer.shares().map(c=>tr(o,c))).then(c=>{this.partner.sendEvent({kind:"DISCLOSE",salt:o,syncerId:this.id,shares:c,formats:this.formats?this.formats.map(l=>l.id):[se.id],canRespond:!1})})}s.size===0&&this.appetite==="once"&&this.partner.sendEvent({kind:"SYNCER_FULFILLED"});break}case"SYNCER_FULFILLED":{this.partnerIsFulfilled.resolve();break}case"HEARTBEAT":break;default:{let{to:t}=e,n=this.syncAgentQueues.get(t);if(!n){let s=new j;s.push(e),this.syncAgentQueues.set(t,s);break}n.push(e)}}}getStatus(){let e={};for(let[t,n]of this.syncAgents)e[t]={docs:n.getStatus(),attachments:this.transferManager.getReport()[t]||[]};return e}onStatusChange(e){return this.statusBus.on(e)}async cancel(e){this.bumpingTimeout.close(),this.isDoneMultiDeferred.reject(e);for(let[t,n]of this.syncAgents)await n.cancel();clearInterval(this.heartbeatInterval),this.transferManager.cancel(),await this.partner.closeConnection()}handleTransferRequest({shareAddress:e,path:t,author:n,source:s,kind:i,formatName:a}){if(this.isDoneMultiDeferred.state!=="pending")return;let o=this.peer.getReplica(e);if(!o)return;let c="unused";if(i==="upload"){let l=this.syncAgents.get(e);l&&(c=l.counterpartId)}return this.transferManager.handleTransferRequest({replica:o,author:n,formatName:a,kind:i,path:t,source:s,counterpartId:c})}isDone(){return this.isDoneMultiDeferred.getPromise()}};function tr(r,e){return F.sha256base32(r+e+r)}var rr=class{constructor(e,t,n,s){this.concurrentTransfers=1024;this.payloadThreshold=1;this.rangeDivision=2;this.outgoingQueue=new j;this.incomingQueue=new j;this.syncAppetite=n,this.partnerPeer=e;let{incomingQueue:i,outgoingQueue:a}=this;this.partnerSyncer=new nt({manager:e.syncerManager,formats:s,partner:{syncAppetite:n,getEvents(){return i},sendEvent(o){return a.push(o),Promise.resolve()},concurrentTransfers:1024,payloadThreshold:32,rangeDivision:32,async getDownload(o){let c=t.getReplica(o.shareAddress);if(!c)throw new f("Tried to get a receiving transfer for an unknown share.");let l=await c.replicaDriver.attachmentDriver.getAttachment(o.doc.format,o.attachmentHash);if(l&&!w(l))return await l.stream()},closeConnection(){return a.close(),Promise.resolve()},handleUploadRequest(o){return Promise.resolve(new ce("PartnerLocal does not support uploads."))},handleTransferRequest(o,c){return Promise.resolve(new ce("PartnerLocal does not support transfer requests."))}}})}getEvents(){return this.outgoingQueue}sendEvent(e){return this.incomingQueue.push(e),Promise.resolve()}closeConnection(){return this.incomingQueue.close(),Promise.resolve()}async getDownload(e){let t=this.partnerPeer.getReplica(e.shareAddress);if(!t)throw new f("Tried to get a receiving transfer for an unknown share.");let n=await t.replicaDriver.attachmentDriver.getAttachment(e.doc.format,e.attachmentHash);if(n&&!w(n))return await n.stream()}handleUploadRequest(e){return Promise.resolve(new ce("PartnerLocal does not support uploads."))}handleTransferRequest(e,t){return Promise.resolve(new ce("PartnerLocal does not support transfer requests."))}};var Xn=class{constructor({socket:e,appetite:t}){this.concurrentTransfers=24;this.payloadThreshold=8;this.rangeDivision=8;this.incomingQueue=new j;this.socketIsReady=T();this.syncAppetite=t,e.readyState===e.OPEN&&this.socketIsReady.resolve(),e.onopen=()=>{this.socketIsReady.resolve()},this.socket=e,this.socket.binaryType="arraybuffer",this.socket.onmessage=n=>{this.incomingQueue.push(JSON.parse(n.data))},this.socket.onclose=()=>{this.incomingQueue.close()},this.socket.onerror=n=>{if("error"in n){this.incomingQueue.close({withError:n.error});return}this.incomingQueue.close({withError:new P("Websocket error.")})}}async sendEvent(e){if(await this.socketIsReady,this.socket.readyState===this.socket.OPEN)return this.socket.send(JSON.stringify(e))}getEvents(){return this.incomingQueue}closeConnection(){return this.socket.close(),Promise.resolve()}getDownload(e){return Promise.resolve(new ce("SyncDriverWebServer does not support download requests."))}handleUploadRequest(e){return Promise.resolve(new ce("SyncDriverWebServer does not support upload requests."))}handleTransferRequest(e,t){if(t==="download"){let n=Gt(e,s=>s);return Promise.resolve(n)}else{let n=Jt(e,s=>s.data instanceof ArrayBuffer?new Uint8Array(s.data):null);return Promise.resolve(n)}}};var nr=class{constructor(e){this.concurrentTransfers=24;this.payloadThreshold=8;this.rangeDivision=8;this.incomingQueue=new j;this.socketIsReady=T();this.syncAppetite=e.appetite;let t=new URL(e.url),n=`${t.host}${t.pathname==="/"?"":t.pathname}`;this.isSecure=t.protocol==="https:"||t.protocol==="wss:",this.wsUrl=`${this.isSecure?"wss://":"ws://"}${n}/'`;let s=new URL(e.appetite,this.wsUrl);this.socket=new WebSocket(s.toString()),this.socket.onopen=()=>{this.socketIsReady.resolve()},this.socket.binaryType="arraybuffer",this.socket.onmessage=i=>{this.incomingQueue.push(JSON.parse(i.data))},this.socket.onclose=()=>{this.incomingQueue.close()},this.socket.onerror=i=>{if("error"in i){this.incomingQueue.close({withError:i.error});return}this.incomingQueue.close({withError:new P("Websocket error.")})}}async sendEvent(e){if(await this.socketIsReady,!(this.socket.readyState===this.socket.CLOSED||this.socket.readyState===this.socket.CLOSING))return this.socket.send(JSON.stringify(e))}getEvents(){return this.incomingQueue}closeConnection(){return this.socket.close(),Promise.resolve()}getDownload(e){let t=new URL(`${e.syncerId}/download/${e.shareAddress}/${e.doc.format}/${e.doc.author}${e.doc.path}`,this.wsUrl),n=Jt(t.toString(),s=>s.data instanceof ArrayBuffer?new Uint8Array(s.data):null);return Promise.resolve(n)}handleUploadRequest(e){let t=new URL(`${e.syncerId}/upload/${e.shareAddress}/${e.doc.format}/${e.doc.author}${e.doc.path}`,this.wsUrl),n=Gt(t.toString(),s=>s);return Promise.resolve(n)}handleTransferRequest(e,t){return Promise.resolve(new ce("SyncDriverWebClient does not support external transfer requests."))}};function Ni(r,e){let[t,n]=r.split(" "),[s,i]=e.split(" "),a=parseInt(t),o=parseInt(s);return a>o?1:a<o?-1:n>i?1:n<i?-1:0}var Ui={lift:r=>Ar(r),combine:(r,e)=>r+e,neutral:BigInt(0)},sr=class extends pt{constructor(){super(Ui,Ni)}};var ir=class{constructor(){this.messagingModes=new Map;this.eagerMessageThumbnails=new Set;this.haveTimeouts=new Map}getMode(e){let t=this.messagingModes.get(e);if(t)return t;let n=this.messagingModes.size===0?"EAGER":"LAZY";return this.messagingModes.set(e,n),"EAGER"}onEagerMessage(e,t){let n=this.haveTimeouts.get(t.thumbnail);return n?(clearTimeout(n),!1):this.eagerMessageThumbnails.has(t.thumbnail)?(this.messagingModes.set(e,"LAZY"),!0):(this.eagerMessageThumbnails.add(t.thumbnail),!1)}onLazyMessage(e,t){if(!this.haveTimeouts.has(e.thumbnail)){let n=setTimeout(()=>{t(e.thumbnail)},5);this.haveTimeouts.set(e.thumbnail,n)}}onGraftMessage(e){this.messagingModes.set(e,"EAGER")}onPrune(e){this.messagingModes.set(e,"LAZY")}};var ar=class{constructor(e){this.syncers=new Map;this.syncerEventBus=new G;this.docThumbnailTreeAndLookup=new Map;this.hasher=new Ce;this.plumTrees=new Map;this.peer=e}addPartner(e,t,n){let s=new nt({manager:this,partner:e,formats:n});return this.syncers.set(s.id,{syncer:s,description:t}),this.syncerEventBus.send(this.syncers),s}getSyncers(){return this.syncers}getDocThumbnailTreeAndDocLookup(e,t){let n=t.map(u=>u.id),s=`${e} ${n}`,i=this.docThumbnailTreeAndLookup.get(s);if(i){let[u,p]=i;return{tree:u,lookup:p,treeIsReady:Promise.resolve(!0)}}let a=this.peer.getReplica(e);if(!a)throw new P("A DocThumbnailTree was requested for a share the peer doesn't know about, big problem!");let o=this.hasher,c=a.getQueryStream({historyMode:"all",orderBy:"localIndex ASC"},"everything",t),l=new sr,h={},d=T();return c.pipeTo(new WritableStream({write(u){if(u.kind==="processed_all_existing"){d.resolve();return}o.reset(),o.update(`${u.doc.path} ${u.doc.author}`);let p=o.digest().toString(16),m=`${u.doc.timestamp} ${p}`;(u.kind==="existing"||u.kind==="success")&&(h[p]=[u.doc.timestamp,u.doc.path,u.doc.author],l.insert(m)),u.kind==="expire"&&(delete h[p],l.remove(m))}})),{tree:l,lookup:h,treeIsReady:d}}getPlumTree(e){let t=this.plumTrees.get(e);if(t)return t;let n=new ir;return this.plumTrees.set(e,n),n}onSyncersChange(e){return this.syncerEventBus.on(e)}};var Ke=new R("peer","orangeRed"),vt=JSON.stringify,st=class{constructor(){this.replicaEventBus=new G;this.replicaMap=new Map;Ke.debug("constructor"),this.syncerManager=new ar(this)}hasShare(e){return this.replicaMap.has(e)}shares(){let e=[...this.replicaMap.keys()];return e.sort(),e}replicas(){let e=[...this.replicaMap.keys()];return e.sort(),e.map(t=>this.replicaMap.get(t))}size(){return this.replicaMap.size}getReplica(e){return this.replicaMap.get(e)}async addReplica(e){if(Ke.debug(`addReplica(${vt(e.share)})`),this.replicaMap.has(e.share))throw Ke.debug("already had a replica with that share"),new Error(`Peer.addReplica: already has a replica with share ${vt(e.share)}.  Don't add another one.`);this.replicaMap.set(e.share,e),await this.replicaEventBus.send(this.replicaMap),Ke.debug("    ...addReplica: done")}async removeReplicaByShare(e){Ke.debug(`removeReplicaByShare(${vt(e)})`),this.replicaMap.delete(e),await this.replicaEventBus.send(this.replicaMap)}async removeReplica(e){let t=this.replicaMap.get(e.share);e===t?(Ke.debug(`removeReplica(${vt(e.share)})`),await this.removeReplicaByShare(e.share)):Ke.debug(`removeReplica(${vt(e.share)}) -- same share but it's a different instance now; ignoring`)}sync(e,t=!1,n){try{let s=new nr({url:e,appetite:t?"continuous":"once"});return this.syncerManager.addPartner(s,e,n)}catch{if(e instanceof st){let s=new rr(e,this,t?"continuous":"once",n);return this.syncerManager.addPartner(s,"Local",n)}console.error("Provided an invalid target for syncing to a peer:",e);return}}addSyncPartner(e,t,n){return this.syncerManager.addPartner(e,t,n)}getSyncers(){return this.syncerManager.getSyncers()}onReplicasChange(e){return this.replicaEventBus.on(e)}onSyncersChange(e){return this.syncerManager.onSyncersChange(e)}discover(e){let t=this;return{async*[Symbol.asyncIterator](){for await(let n of e.events){if(n.kind==="SERVICE_STOPPED")break;if(n.kind==="PEER_EXITED"){yield n;continue}if(n.kind==="PEER_INITIATED_SYNC"){let s=await n.begin(t);yield{kind:"PEER_INITIATED_SYNC",description:n.description,syncer:s};continue}yield{kind:"PEER_DISCOVERED",description:n.description,sync:async s=>await n.begin(t,s?.syncContinuously?"continuous":"once")}}}}}};var es={historyMode:"latest",orderBy:"path ASC",startAfter:void 0,limit:void 0,filter:void 0,formats:["es.5"]};var We=new R("query","green");function it(r){let e={...es,...r},t={query:{limit:0},isValid:!1,willMatch:"nothing"};if(e.limit!==void 0&&e.limit<0)return We.debug("cleanUpQuery: unreasonable limit - returning empty invalid query",t),t;if(e.orderBy?.startsWith("path")&&e.startAfter?.localIndex!==void 0)return We.debug('cleanUpQuery: orderBy is "path" but startAfter is not compatible - returning empty invalid query',t),t;if(e.orderBy?.startsWith("localIndex")&&e.startAfter?.path!==void 0)return We.debug('cleanUpQuery: orderBy is "localIndex" but startAfter is not compatible - returning empty invalid query',t),t;if(e.historyMode!==void 0&&e.historyMode!=="all"&&e.historyMode!=="latest")return We.debug(`cleanUpQuery: unknown historyMode ${JSON.stringify(e.historyMode)} - returning empty invalid query`,t),t;if(e.orderBy!==void 0&&["path ASC","path DESC","localIndex ASC","localIndex DESC"].indexOf(e.orderBy)===-1)return We.debug(`cleanUpQuery: unrecognized orderBy value ${JSON.stringify(e.orderBy)} - returning empty invalid query`,t),t;let n=e.historyMode==="all"?"all":"all-latest";if(e.filter!==void 0&&!we(e.filter,{})&&(n="some"),e.startAfter!==void 0&&!we(e.startAfter,{})&&(n="some"),e.limit!==void 0&&(e.limit>0&&(n="some"),e.limit===0&&(n="nothing")),e.filter!==void 0){let s=e.filter;s.path&&s.pathStartsWith&&!s.path.startsWith(s.pathStartsWith)&&(n="nothing"),s.path&&s.pathEndsWith&&!s.path.endsWith(s.pathEndsWith)&&(n="nothing"),s.timestamp&&s.timestampGt&&!(s.timestamp>s.timestampGt)&&(n="nothing"),s.timestamp&&s.timestampLt&&!(s.timestamp<s.timestampLt)&&(n="nothing"),s.timestampGt&&s.timestampLt&&!(s.timestampLt+1<s.timestampGt)&&(n="nothing")}if(n==="nothing"){let s={query:{limit:0},isValid:!0,willMatch:"nothing"};return We.debug("cleanUpQuery - this query will match nothing, so returning a simpler query that also matches nothing",s),s}return We.debug(`cleanUpQuery - query is ok!  willMatch = ${n}`),{query:e,isValid:!0,willMatch:n}}function Le(r,e){return!(e.path!==void 0&&r.path!==e.path||e.pathStartsWith!==void 0&&!r.path.startsWith(e.pathStartsWith)||e.pathEndsWith!==void 0&&!r.path.endsWith(e.pathEndsWith)||e.author!==void 0&&r.author!==e.author||e.timestamp!==void 0&&r.timestamp!==e.timestamp||e.timestampGt!==void 0&&!(r.timestamp>e.timestampGt)||e.timestampLt!==void 0&&!(r.timestamp<e.timestampLt))}function ts(r,e){return r.deleteAfter===null||r.deleteAfter===void 0?!1:(e||Date.now()*1e3)>r.deleteAfter}var Ru=new R("query helpers","gold"),Oi=/[.*+?^${}()|[\]\\]/g;function Vi(r){return r.replace(Oi,"\\$&")}var qi=(r,e)=>{if(r.flags.indexOf("g")===-1)throw new TypeError('matchAll requires a regex with the "g" flag set');let t=[],n;for(;(n=r.exec(e))!==null;)t.push(n);return t},At=(r,e=!0)=>{if(r.indexOf("***")!==-1)throw new f("invalid glob query has three stars in a row: "+r);let t=wt(r,"**",";");return t=wt(t,"*","#"),t=Vi(t),t=wt(t,";",".*"),t=wt(t,"#","[^/]*"),e&&(t="^"+t+"$"),t},rs=r=>{if(r.indexOf("*")===-1)return{query:{filter:{path:r}},regex:null};let e=r.split("*"),t=e[0],n=e[e.length-1],s={},i={};t&&(s.pathStartsWith=t),n&&(s.pathEndsWith=n);let a="?";if(e.length===3){let[o,c,l]=e;o===""&&c===""&&(a=null),c===""&&l===""&&(a=null)}return a==="?"&&(a=At(r)),Nn(s)||(i.filter=s),{query:i,regex:a}};async function Cu(r,e,t={},n){let{query:s,regex:i}=rs(e);s={...s,...t};let a=await r.queryDocs(s,n);if(i!==null){let o=new RegExp(i);a=a.filter(c=>o.test(c.path))}return a}function ns(r){if(r.indexOf("}{")!==-1)throw new f("template is not allowed to have to adjacent variables {like}{this}");if(r.indexOf("*{")!==-1||r.indexOf("}*")!==-1)throw new f("template cannot have a star touching a variable *{likeThis}");let e=Pr(r,"{"),t=Pr(r,"}");if(e!==t)throw new f("unbalanced curly braces");let n=/\{(.*?)\}/g,s=/^[a-zA-Z_][a-zA-Z0-9_]*$/,i=qi(n,r),a=i.map(d=>d[1]);for(let d of a)if(!s.test(d))throw new f("variable name in template is not valid.  can only contain alphanumeric and underscore, and not start with number");if(e!==a.length||t!==a.length)throw new f("weird curly brace mismatch, maybe }backwards{");if(new Set(a).size!==a.length)throw new f("variable names may not be repeated");let c=r.replace(n,"*"),l=[];i.length===0&&l.push(At(r,!1));for(let d=0;d<i.length;d++){let u=i[d],p=u[1],m=u.index,g=u.index+u[0].length;if(d===0){let S=r.slice(0,m);l.push(At(S,!1))}let v="(?<"+p+">[^/]*)";if(l.push(v),d<=i.length-2){let S=i[d+1],_=r.slice(g,S.index);l.push(At(_,!1))}else{let S=r.slice(g);l.push(At(S,!1))}}let h="^"+l.join("")+"$";return{template:r,varNames:a,glob:c,namedCaptureRegex:h}}var Ki=(r,e)=>{let t=e.match(new RegExp(r));return t===null?null:{...t.groups}},Pu=(r,e)=>{if(r.indexOf("{")===-1&&r.indexOf("}")===-1)return r===e?{}:null;let{namedCaptureRegex:t}=ns(r);return Ki(t,e)},Fu=(r,e)=>{for(let[t,n]of Object.entries(r))e=e.replace("{"+t+"}",n);return e};async function Lu(r,e,t={},n){let{glob:s}=ns(e),{query:i,regex:a}=rs(s);i={...i,...t};let o=await r.queryDocs(i,n);if(a!=null){let c=new RegExp(a);o=o.filter(l=>c.test(l.path))}return o}var zr=(n=>(n[n.LT=-1]="LT",n[n.EQ=0]="EQ",n[n.GT=1]="GT",n))(zr||{});function ss(r){return r.sort(),r}function or(r,e,t="ASC"){if(Array.isArray(r)&&Me(r,e))return 0;if(typeof r=="object"&&we(r,e))return 0;if(r===e)return 0;if(t==="ASC"||t===void 0)return r<e?-1:1;if(t==="DESC")return r>e?-1:1;throw new Error("unexpected sort order to compareBasic: "+JSON.stringify(t))}function Ie(r,e,t){let n=Math.min(r.length,e.length);for(let a=0;a<n;a++){let o=t?.[a]??"ASC",c=or(r[a],e[a],o);if(c!==0)return c}if(r.length===e.length)return 0;let s=Math.min(r.length,e.length),i=t?.[s]??"ASC";return or(r.length,e.length,i)}function at(r,e="ASC"){return(t,n)=>or(t[r],n[r],e)}function Ou(r){return(e,t)=>or(r(e),r(t))}function Vu(r){return(e,t)=>Ie(r(e),r(t))}var Wi=JSON.stringify,ee=new R("replica","gold"),te=new R("replica set","gold"),J=new R("replica ingest","gold");function is(r,e){return Ie([r.timestamp,r.signature],[e.timestamp,r.signature],["DESC","ASC"])}var cr=class{constructor({driver:e,config:t}){this._isClosed=!1;this.ingestLockStream=new Tt;this.eventMultiStream=new zt("kind",!0);this.callbackSink=new et;this.expireEventTimeouts=new Map;let n=X(e.docDriver.share);if(w(n))throw n;ee.debug(`constructor.  driver = ${e?.constructor?.name}`),this.replicaId="replica-"+re(),this.share=e.docDriver.share,this.replicaDriver=e,this.formatsConfig=t||{},this.eventWriter=this.eventMultiStream.getWritableStream().getWriter(),this.eventMultiStream.getReadableStream("*").pipeTo(new WritableStream(this.callbackSink)),this.eraseInterval=setInterval(()=>{this.isClosed()?clearInterval(this.eraseInterval):this.pruneExpiredDocsAndAttachments()},1e3*60*60)}isClosed(){return this._isClosed}async close(e){if(ee.debug("closing..."),this._isClosed)throw new A;await this.ingestLockStream.close();for(let t of this.expireEventTimeouts.values())clearTimeout(t);return ee.debug("    sending willClose blockingly..."),await this.eventWriter.write({kind:"willClose"}),ee.debug("    marking self as closed..."),e===!1&&await this.pruneExpiredDocsAndAttachments(),await this.replicaDriver.attachmentDriver.clearStaging(),this._isClosed=!0,ee.debug(`    closing ReplicaDriver (erase = ${e})...`),await this.replicaDriver.docDriver.close(e),await this.replicaDriver.attachmentDriver.close(e),clearInterval(this.eraseInterval),ee.debug("    sending didClose nonblockingly..."),await this.eventWriter.write({kind:"didClose"}),ee.debug("...closing done"),Promise.resolve()}async getConfig(e){if(this._isClosed)throw new A;return await this.replicaDriver.docDriver.getConfig(e)}async setConfig(e,t){if(this._isClosed)throw new A;return await this.replicaDriver.docDriver.setConfig(e,t)}async listConfigKeys(){if(this._isClosed)throw new A;return await this.replicaDriver.docDriver.listConfigKeys()}async deleteConfig(e){if(this._isClosed)throw new A;return await this.replicaDriver.docDriver.deleteConfig(e)}getMaxLocalIndex(){if(this._isClosed)throw new A;return this.replicaDriver.docDriver.getMaxLocalIndex()}getAllDocs(e){return ee.debug("getAllDocs()"),this.queryDocs({historyMode:"all",orderBy:"path ASC"},e)}getLatestDocs(e){return ee.debug("getLatestDocs()"),this.queryDocs({historyMode:"latest",orderBy:"path ASC"},e)}getAllDocsAtPath(e,t){return ee.debug(`getAllDocsAtPath("${e}")`),this.queryDocs({historyMode:"all",orderBy:"path ASC",filter:{path:e}},t)}async getLatestDocAtPath(e,t){ee.debug(`getLatestDocsAtPath("${e}")`);let n=await this.queryDocs({historyMode:"latest",orderBy:"path ASC",filter:{path:e}},t?[t]:void 0);if(n.length!==0)return n[0]}async queryDocs(e={},t){if(ee.debug("queryDocs",e),this._isClosed)throw new A;let n=Ee(t);return await this.replicaDriver.docDriver.queryDocs({...e,formats:n.map(s=>s.id)})}async queryPaths(e={},t){let n=await this.queryDocs(e,t),s=new Set(n.map(({path:i})=>i));return Array.from(s).sort()}async queryAuthors(e={},t){let n=await this.queryDocs(e,t),s=new Set(n.map(({author:i})=>i));return Array.from(s).sort()}async set(e,t,n=se){if(te.debug("set",t),this._isClosed)throw new A;te.debug("...deciding timestamp: getting latest doc at the same path (from any author)");let s=await this.getLatestDocAtPath(t.path),i;typeof t.timestamp=="number"?i=t.timestamp:s===void 0?i=Cr():i=Math.max(Cr(),s.timestamp+1),te.debug("...generating doc");let a;if(s){let l=n.removeExtraFields(s);w(l)||(a=l.doc)}let o=await n.generateDocument({keypair:e,input:{...t,format:n.id},share:this.share,timestamp:i,prevLatestDoc:a,config:this.formatsConfig[n.id]});if(w(o))return{kind:"failure",reason:"invalid_document",err:o};if(te.debug("...signature =",o.doc.signature),o.attachment){let l=await this.replicaDriver.attachmentDriver.stage(n.id,o.attachment);if(w(l))return{kind:"failure",reason:"invalid_document",err:l};let h=await n.updateAttachmentFields(e,o.doc,l.size,l.hash,this.formatsConfig[n.id]);if(w(h))return await l.reject(),{kind:"failure",reason:"invalid_document",err:h};te.debug("...ingesting attachment"),te.debug("-----------------------"),await l.commit(),await this.eventWriter.write({kind:"attachment_ingest",doc:h,hash:l.hash,size:l.size,sourceId:"local"}),te.debug("...done ingesting attachment"),te.debug("...ingesting"),te.debug("-----------------------");let d=await this.ingest(n,h,"local");return te.debug("...done ingesting"),te.debug("...set is done."),d}te.debug("...ingesting"),te.debug("-----------------------");let c=await this.ingest(n,o.doc,"local");return te.debug("...done ingesting"),te.debug("...set is done."),c}async ingest(e,t,n){if(J.debug("ingest",t),this._isClosed)throw new A;J.debug("...removing extra fields");let s=e.removeExtraFields(t);if(w(s))return{kind:"failure",reason:"invalid_document",err:s};t=s.doc;let i=s.extras;Object.keys(i).length>0&&J.debug(`...extra fields found: ${Wi(i)}`);let a=await e.checkDocumentIsValid(t);if(w(a))return{kind:"failure",reason:"invalid_document",err:a};let o=T();return await this.ingestLockStream.run(async()=>{J.debug(" >> ingest: start of protected region"),J.debug("  > getting other history docs at the same path by any author");let c=await this.getAllDocsAtPath(t.path,[e]);J.debug(`  > ...got ${c.length}`),J.debug("  > getting prevLatest and prevSameAuthor");let l=c[0]??null,h=c.filter(g=>g.author===t.author)[0]??null;J.debug("  > checking if new doc is latest at this path"),c.push(t),c.sort(is);let d=c[0]===t;if(J.debug(`  > ...isLatest: ${d}`),!d&&h!==null){J.debug("  > new doc is not latest and there is another one from the same author...");let g=is(t,h);if(g===1){J.debug("  > new doc is GT prevSameAuthor, so it is obsolete"),o.resolve({kind:"nothing_happened",reason:"obsolete_from_same_author",doc:t});return}if(g===0){J.debug("  > new doc is EQ prevSameAuthor, so it is redundant (already_had_it)"),o.resolve({kind:"nothing_happened",reason:"already_had_it",doc:t});return}}J.debug("  > upserting into ReplicaDriver...");let u=await this.replicaDriver.docDriver.upsert(t);J.debug("  > ...done upserting into ReplicaDriver"),J.debug("  > ...getting ReplicaDriver maxLocalIndex...");let p=await this.replicaDriver.docDriver.getMaxLocalIndex();J.debug(" >> ingest: end of protected region, returning a WriteEvent from the lock");let m={kind:"success",maxLocalIndex:p,doc:u,docIsLatest:d,prevDocFromSameAuthor:h,prevLatestDoc:l,sourceId:n};if(o.resolve(m),await this.eventWriter.write(m),u.deleteAfter){let g=`${u.path}|${u.author}`,v=this.expireEventTimeouts.get(g);v&&clearTimeout(v);let S=u.deleteAfter/1e3-Date.now();this.expireEventTimeouts.set(g,setTimeout(()=>{this.eventWriter.write({kind:"expire",doc:u})},S))}}),o}async overwriteAllDocsByAuthor(e,t){let n=_r(t);if(ee.debug(`overwriteAllDocsByAuthor("${e.address}")`),this._isClosed)throw new A;let s=await this.queryDocs({filter:{author:e.address},historyMode:"all"},[n]);ee.debug(`    ...found ${s.length} docs to overwrite`);let i=0,a=0;for(let o of s){let c=await this.wipeDocument(e,o,_r(t));if(w(c))return c;i+=1}return ee.debug(`    ...done; ${i} overwritten to be empty; ${a} were already empty; out of total ${s.length} docs`),i}async wipeDocAtPath(e,t,n=se){let s=await this.getLatestDocAtPath(t,n);return s?this.wipeDocument(e,s,n):new f("No document exists at that path")}async wipeDocument(e,t,n){let s={...t,timestamp:Math.max(t.timestamp+1,Date.now()*1e3),author:e.address},i=await n.wipeDocument(e,s,this.formatsConfig[n.id]);if(w(i))return{kind:"failure",err:i,reason:"invalid_document"};let a=await this.ingest(n,i,"local");if(a.kind==="success"){let o=n.getAttachmentInfo(t);if(!w(o)){let c=await this.replicaDriver.attachmentDriver.erase(n.id,o.hash);w(c)||await this.eventWriter.write({kind:"attachment_prune",format:n.id,hash:o.hash})}}return a}async pruneExpiredDocsAndAttachments(e=Xe){let t=await this.replicaDriver.docDriver.eraseExpiredDocs();for(let a of t)await this.eventWriter.write({kind:"expire",doc:a});let n=ve(e),s={};await this.getQueryStream({historyMode:"all",orderBy:"localIndex ASC"},"existing",e).pipeTo(new WritableStream({write(a){if(a.kind==="existing"){let o=n[a.doc.format],c=o.getAttachmentInfo(a.doc);if(!w(c)){let l=s[o.id];l?l.add(c.hash):s[o.id]=new Set([c.hash])}}}}));let i=await this.replicaDriver.attachmentDriver.filter(s);for(let a of i)await this.eventWriter.write({kind:"attachment_prune",format:a.format,hash:a.hash})}getEventStream(e="*"){return this.eventMultiStream.getReadableStream(e)}getQueryStream(e={},t,n){let s=this.queryDocs.bind(this),i=this.getEventStream.bind(this);return new ReadableStream({async start(a){if(t==="existing"||t==="everything"){let l=await s(e,n);for(let h of l)a.enqueue({kind:"existing",doc:h})}if(a.enqueue({kind:"processed_all_existing"}),t==="existing"){a.close();return}let c=i().getReader();for(;;){let{done:l,value:h}=await c.read();if(l)return;if(h.kind==="expire"||h.kind==="success"){if(e.filter&&Le(h.doc,e.filter)){a.enqueue(h);continue}a.enqueue(h);continue}h.kind==="didClose"&&a.close()}}})}onEvent(e){return this.callbackSink.onWrite(e)}async ingestAttachment(e,t,n,s){if(this._isClosed)throw new A;let i=e.removeExtraFields(t);if(w(i))return Promise.resolve(i);t=i.doc;let a=await e.checkDocumentIsValid(t);if(w(a))return Promise.resolve(a);let o=await this.getAttachment(t,e);if(o&&!w(o))return!1;let c=e.getAttachmentInfo(t);if(w(c))return Promise.resolve(c);let l=await this.replicaDriver.attachmentDriver.stage(t.format,n);return w(l)?l:l.hash!==c.hash?(await l.reject(),new f("Attachment's hash did not match the document's")):l.size!==c.size?(await l.reject(),new f("Attachment's size did not match the document's")):(await l.commit(),await this.eventWriter.write({kind:"attachment_ingest",doc:t,hash:l.hash,size:l.size,sourceId:s}),!0)}getAttachment(e,t=se){if(e.deleteAfter&&e.deleteAfter<Date.now()*1e3)return Promise.resolve(new f("This document has expired"));let n=t.getAttachmentInfo(e);return w(n)?Promise.resolve(n):this.replicaDriver.attachmentDriver.getAttachment(e.format,n.hash)}addAttachments(e,t){let n=Ee(t),s={};for(let a of n)s[a.id]=a;let i=e.map(a=>new Promise(o=>{let l=s[a.format].getAttachmentInfo(a);if(!w(l))this.replicaDriver.attachmentDriver.getAttachment(a.format,l.hash).then(h=>{o({...a,attachment:h})});else return o({...a,attachment:l})}));return Promise.all(i)}};var as=class extends cr{constructor(e){super({driver:e.driver,config:{"es.5":{shareSecret:e.shareSecret}}})}};var $e=new R("replica-cache","green");function os({_localIndex:r}){return r}function cs(r,e){let t=[];for(let n of e)if(!(r.orderBy==="path ASC"&&r.startAfter!==void 0&&r.startAfter.path!==void 0&&n.path<=r.startAfter.path)&&!(r.orderBy==="path DESC"&&r.startAfter!==void 0&&r.startAfter.path!==void 0&&n.path>=r.startAfter.path)&&!(r.orderBy==="localIndex ASC"&&r.startAfter!==void 0&&r.startAfter.localIndex!==void 0&&(n._localIndex||0)<=r.startAfter.localIndex)&&!(r.orderBy==="localIndex DESC"&&r.startAfter!==void 0&&r.startAfter.localIndex!==void 0&&(n._localIndex||0)>=r.startAfter.localIndex)&&(t.push(n),r.limit!==void 0&&t.length>=r.limit))break;return t}var ls=class{constructor(e,t,n){this.version=0;this.docCache=new Map;this.onCacheUpdatedCallbacks=new Set;this.closed=!1;this.onFireCacheUpdatedsWrapper=e=>e();this.attachmentCache=new Map;this.replica=e,this.timeToLive=t||1e3,n&&(this.onFireCacheUpdatedsWrapper=n);let s=this.onReplicaEvent.bind(this),i=this.close.bind(this),a=this.isClosed.bind(this);this.replica.getEventStream("*").pipeTo(new WritableStream({async write(o){o.kind==="attachment_ingest"||o.kind==="success"||o.kind==="expire"?await s(o):o.kind==="willClose"&&!a()&&await i()}})).catch(()=>{})}async close(){if(this.closed)throw new ye;this.closed=!0,await Promise.all(Array.from(this.docCache.values()).map(e=>e.close())),this.docCache.clear(),this.onCacheUpdatedCallbacks.clear()}isClosed(){return this.closed}getAllDocs(e){return this.queryDocs({historyMode:"all",orderBy:"path DESC"},e)}getLatestDocs(e){return this.queryDocs({historyMode:"latest",orderBy:"path DESC"},e)}getAllDocsAtPath(e,t){return this.queryDocs({historyMode:"all",orderBy:"path DESC",filter:{path:e}},t)}getLatestDocAtPath(e,t){let n=this.queryDocs({historyMode:"latest",orderBy:"path DESC",filter:{path:e}},t?[t]:void 0);if(n.length!==0)return n[0]}queryDocs(e={},t){if(this.closed)throw new ye;if(this.replica.isClosed())throw new A;let s={...e,formats:(t||Xe).map(m=>m.id)},i=it(s);if(i.willMatch==="nothing")return[];let a=(0,xr.default)(i.query),o=this.docCache.get(a);if(o)return Date.now()>o.expires&&this.replica.queryDocs(e,t).then(m=>{let g=m.map(os).sort(),v=o.docs.map(os).sort();Me(g,v)||(this.docCache.set(a,{stream:o.stream,close:o.close,docs:m,expires:Date.now()+this.timeToLive}),$e.debug("Updated cache because result expired."),this.fireOnCacheUpdateds())}),o.docs;let c=this.replica.getQueryStream(e,"new",t),l=new et,h=l.onWrite(m=>{(m.kind==="existing"||m.kind==="success")&&($e.debug({doc:m.doc.path,queryString:a}),this._updateCache(a,m.doc))}),d=new WritableStream(l),u=new AbortController;c.pipeTo(d,{signal:u.signal});let p=()=>{h()};return this.docCache.set(a,{stream:c,docs:[],expires:Date.now()+this.timeToLive,close:p}),this.replica.queryDocs(s).then(m=>{this.docCache.set(a,{stream:c,close:p,docs:m,expires:Date.now()+this.timeToLive}),$e.debug("Updated cache with a new entry."),this.fireOnCacheUpdateds()}),[]}queryPaths(e={},t){let n=this.queryDocs(e,t),s=new Set(n.map(({path:i})=>i));return Array.from(s).sort()}queryAuthors(e={},t){let n=this.queryDocs(e,t),s=new Set(n.map(({author:i})=>i));return Array.from(s).sort()}_updateCache(e,t){let n=this.docCache.get(e);if(!n)return;let s=JSON.parse(e),i=()=>{let p=[...n.docs,t];this.docCache.set(e,{...n,docs:cs(s,p)}),this.fireOnCacheUpdateds()},a=({exact:p})=>{let m=n.docs.map(g=>p&&g.path===t.path&&g.author===t.author||!p&&g.path===t.path?t:g);this.docCache.set(e,{...n,docs:cs(s,m)}),this.fireOnCacheUpdateds()},o=n.docs.filter(p=>p.path===t.path),c=n.docs.filter(p=>p.path===t.path&&p.author===t.author);if(o.length===0){(s.filter&&Le(t,s.filter)||!s.filter)&&($e.debug("Updated cache after appending a doc to a entry with matching filter."),i());return}if((s.historyMode||"latest")==="all"){if(c.length===0){$e.debug("Updated cache after appending a version of a doc to a historyMode: all query."),i();return}$e.debug("Updated cache after replacing a version of a doc in a historyMode: all query."),a({exact:!0});return}let h=o[0],d=t.author!==h?.author||!we(t,h),u=t.timestamp>h.timestamp;if(d&&u){$e.debug("Updated cache after replacing a doc with its latest version."),a({exact:!1});return}}fireOnCacheUpdateds(){this.version++,this.onFireCacheUpdatedsWrapper(()=>{this.onCacheUpdatedCallbacks.forEach(e=>{e()})})}onCacheUpdated(e){if(this.closed)throw new ye;if(this.replica.isClosed())throw new A;return this.onCacheUpdatedCallbacks.add(e),()=>{this.onCacheUpdatedCallbacks.delete(e)}}set(e,t,n){if(this.closed)throw new ye;return this.replica.set(e,t,n)}overwriteAllDocsByAuthor(e,t){if(this.closed)throw new ye;if(this.replica.isClosed())throw new A;return this.replica.overwriteAllDocsByAuthor(e,t)}wipeDocAtPath(e,t,n=se){if(this.closed)throw new ye;return this.replica.wipeDocAtPath(e,t,n)}async onReplicaEvent(e){let t=`${e.doc.path}|${e.doc.author}`,n=this.attachmentCache.get(t);if(!n)return;let s=await this.replica.getAttachment(e.doc,n.format);this.attachmentCache.set(t,{expires:Date.now()+this.timeToLive,attachment:s,format:n.format}),this.fireOnCacheUpdateds()}getAttachment(e,t=se){if(this.closed)throw new ye;if(this.replica.isClosed())throw new A;let n=t.getAttachmentInfo(e);if(w(n))return n;let s=`${e.path}|${e.author}`,i=this.attachmentCache.get(s);if(i)return Date.now()>i.expires&&this.replica.getAttachment(e,t).then(a=>{this.attachmentCache.set(s,{expires:Date.now()+this.timeToLive,attachment:a,format:t}),this.fireOnCacheUpdateds()}),e.deleteAfter&&Date.now()*1e3>e.deleteAfter?new f("This document has expired"):i.attachment;this.attachmentCache.set(s,{attachment:void 0,expires:Date.now()+this.timeToLive,format:t}),this.replica.getAttachment(e,t).then(a=>{this.attachmentCache.set(s,{expires:Date.now()+this.timeToLive,attachment:a,format:t}),this.fireOnCacheUpdateds()})}addAttachments(e,t){let n=[],s=ve(t);for(let i of e){let a=this.getAttachment(i,s[i.format]);n.push({...i,attachment:a})}return n}};var de=new R("storage driver async memory","yellow");function us(r){return`${r.path}|${r.author}`}function ds(r,e){return Ie([r.path,r.timestamp,r.signature],[e.path,e.timestamp,r.signature],["ASC","DESC","ASC"])}function $i(r,e){return Ie([r.path,r.timestamp,r.signature],[e.path,e.timestamp,r.signature],["DESC","DESC","ASC"])}var ot=class{constructor(e){this._maxLocalIndex=-1;this._isClosed=!1;this._configKv={};this.docByPathAndAuthor=new Map;this.docsByPathNewestFirst=new Map;this.latestDocsByPath=new Map;de.debug("constructor");let t=X(e);if(w(t))throw t;this.share=e}isClosed(){return this._isClosed}close(e){if(de.debug("close"),this._isClosed)throw new A;return e&&(de.debug("...close: and erase"),this._configKv={},this._maxLocalIndex=-1,this.docsByPathNewestFirst.clear(),this.docByPathAndAuthor.clear()),this._isClosed=!0,de.debug("...close is done."),Promise.resolve()}async getConfig(e){if(this._isClosed)throw new A;return this._configKv[e]}async setConfig(e,t){if(this._isClosed)throw new A;this._configKv[e]=t}async listConfigKeys(){if(this._isClosed)throw new A;return ss(Object.keys(this._configKv))}async deleteConfig(e){if(this._isClosed)throw new A;let t=e in this._configKv;return delete this._configKv[e],t}getMaxLocalIndex(){if(this._isClosed)throw new A;return de.debug(`getMaxLocalIndex(): it's ${this._maxLocalIndex}`),Promise.resolve(this._maxLocalIndex)}async _getAllDocs(){if(this._isClosed)throw new A;return[...this.docByPathAndAuthor.values()]}async _getLatestDocs(){if(this._isClosed)throw new A;return Array.from(this.latestDocsByPath.values())}async queryDocs(e){if(de.debug("queryDocs",e),this._isClosed)throw new A;let{query:t,willMatch:n}=it(e);if(de.debug(`    cleanUpQuery.  willMatch = ${n}`),n==="nothing")return[];if(t.historyMode==="latest"&&t.filter?.path){let o=this.latestDocsByPath.get(t.filter.path);return o&&o.deleteAfter&&o.deleteAfter<Date.now()*1e3?[]:o?[o]:[]}if(t.historyMode==="all"&&t.filter?.path){let o=this.docsByPathNewestFirst.get(t.filter.path);if(o){let c=[];for(let l of o)(l.deleteAfter===null||l.deleteAfter===void 0)&&c.push(l),l.deleteAfter&&l.deleteAfter>Date.now()*1e3&&c.push(l);return c}return[]}de.debug(`    getting docs; historyMode = ${t.historyMode}`);let s=t.historyMode==="all"?await this._getAllDocs():await this._getLatestDocs(),i=[];de.debug("    filtering docs");let a=Date.now()*1e3;for(let o of s)t.orderBy==="path ASC"&&t.startAfter!==void 0&&t.startAfter.path!==void 0&&o.path<=t.startAfter.path||t.orderBy==="path DESC"&&t.startAfter!==void 0&&t.startAfter.path!==void 0&&o.path>=t.startAfter.path||t.orderBy==="localIndex ASC"&&t.startAfter!==void 0&&t.startAfter.localIndex!==void 0&&(o._localIndex??0)<=t.startAfter.localIndex||t.orderBy==="localIndex DESC"&&t.startAfter!==void 0&&t.startAfter.localIndex!==void 0&&(o._localIndex??0)>=t.startAfter.localIndex||o.deleteAfter&&o.deleteAfter<a||t.filter&&!Le(o,t.filter)||i.push(o);if(de.debug(`    ordering docs: ${t.orderBy}`),t.orderBy==="path ASC")i.sort(ds);else if(t.orderBy==="path DESC")i.sort($i);else if(t.orderBy==="localIndex ASC")i.sort(at("_localIndex","ASC"));else if(t.orderBy==="localIndex DESC")i.sort(at("_localIndex","DESC"));else if(t.orderBy)throw new f("unrecognized query orderBy: "+JSON.stringify(t.orderBy));return t.limit!==void 0&&s.length>=t.limit?i.slice(0,t.limit):(de.debug(`    queryDocs is done: found ${i.length} docs.`),i)}upsert(e){if(this._isClosed)throw new A;e={...e},this._maxLocalIndex+=1,e._localIndex=this._maxLocalIndex,Object.freeze(e),de.debug("upsert",e),this.docByPathAndAuthor.set(us(e),e);let t=this.docsByPathNewestFirst.get(e.path)??[];t=t.filter(s=>s.author!==e.author),t.push(e),t.sort(ds),this.docsByPathNewestFirst.set(e.path,t);let n=t[0];return this.latestDocsByPath.set(e.path,n),Promise.resolve(e)}eraseExpiredDocs(){let e=[];for(let[,t]of this.docByPathAndAuthor)ts(t)&&e.push(t);for(let t of e)this.docsByPathNewestFirst.delete(t.path),this.latestDocsByPath.delete(t.path),this.docByPathAndAuthor.delete(us(t));return Promise.resolve(e)}};async function lr(r){let e=new Uint8Array;return await r.pipeTo(new WritableStream({write(t){let n=new Uint8Array(e.length+t.length);n.set(e),n.set(t,e.length),e=n}})),e}var ur=class{constructor(){this.stagingMap=new Map;this.attachmentMap=new Map;this.closed=!1}getKey(e,t){return`${e}___${t}`}getAttachment(e,t){if(this.closed)throw new A;let n=this.getKey(e,t),s=this.attachmentMap.get(n);return s?Promise.resolve({bytes:async()=>new Uint8Array(await s.arrayBuffer()),stream:()=>Promise.resolve(s.stream())}):Promise.resolve(void 0)}async stage(e,t){if(this.closed)throw new A;let n=t instanceof Uint8Array?t:await lr(t),s=await F.sha256base32(n),i=new Blob([n]),a=this.getKey(e,s);return this.stagingMap.set(a,i),Promise.resolve({hash:s,size:n.byteLength,commit:()=>(this.attachmentMap.set(a,i),this.stagingMap.delete(a),Promise.resolve()),reject:()=>(this.stagingMap.delete(a),Promise.resolve())})}erase(e,t){if(this.closed)throw new A;let n=this.getKey(e,t);return this.attachmentMap.has(n)?(this.attachmentMap.delete(n),Promise.resolve(!0)):Promise.resolve(new f("No attachment with that signature found."))}wipe(){if(this.closed)throw new A;return this.attachmentMap.clear(),Promise.resolve()}async filter(e){if(this.closed)throw new A;let t=[];for(let n of this.attachmentMap.keys()){let[s,i]=n.split("___"),a=e[s];a&&!a.has(i)&&await this.erase(s,i)&&t.push({format:s,hash:i})}return t}clearStaging(){if(this.closed)throw new A;return this.stagingMap.clear(),Promise.resolve()}isClosed(){return this.closed}async close(e){if(this.closed)throw new A;e&&await this.wipe(),this.closed=!0}};var hs=class{constructor(e){this.docDriver=new ot(e),this.attachmentDriver=new ur}};async function Ed(r,e,t){let n=yt(r);if(w(n))return new f("Invalid share address.");for(let o of e)try{new URL(o)}catch{return new f(`Could not parse ${o} as a URL.`)}let s=e.map(o=>`&server=${o}`).join("&"),i="";if(t){let o=await F.checkKeypairIsValid({shareAddress:r,secret:t});if(w(o))return new f(`Supplied the wrong secret for ${r}`);i=`&secret=${t}`}return`earthstar://${r}/?invite${s}${i}&v=2`}async function ps(r){try{let e=new URL(r),t=e.hostname.length>0?e.hostname:e.pathname.replaceAll("/",""),n=yt(t);if(w(n))return new f("Invitation did not include a valid share address.");let s=new URLSearchParams(e.search),i=s.get("invite"),a=s.get("v");if(i===null)return new f("Not an invitation URL");if(a===null)return new f("Invitation version not specified.");if(a!=="2")return new f(`Invitation version is ${a}, expected version 2.`);let o=s.getAll("server");for(let l of o)try{new URL(l)}catch{return new f(`Invitation's servers included a malformed URL: ${l}`)}let c=s.get("secret");if(c){let l=await F.checkKeypairIsValid({shareAddress:t,secret:c});if(w(l))return new f(`Invitation contains the wrong secret for share ${t}.`)}return{shareAddress:t,secret:c||void 0,servers:o}}catch{return new f("Could not parse the invitation URL.")}}var Qi="earthstar",dr="current_author",St="shares",Dt="share_secrets",xt="servers",fs=class{constructor(e){this.storage=localStorage;this.authorChangedCbs=new Set;this.sharesChangedCbs=new Set;this.shareSecretsChangedCbs=new Set;this.serversChangedCbs=new Set;this.namespace=e?.namespace,e?.sessionOnly&&(this.storage=sessionStorage),addEventListener("storage",t=>{switch(t.key){case $(dr,this.namespace):{this.fireAuthorEvent();break}case $(St,this.namespace):{this.fireSharesEvent();break}case $(Dt,this.namespace):{this.fireSecretsEvent();break}case $(xt,this.namespace):{this.fireServersEvent();break}}})}get author(){let e=$(dr,this.namespace);return hr(this.storage,e,ji)||null}set author(e){let t=$(dr,this.namespace);this.storage.setItem(t,JSON.stringify(e)),this.fireAuthorEvent()}get shares(){let e=$(St,this.namespace);return hr(this.storage,e,Hi)||[]}addShare(e){if(w(X(e)))return new f("Not a valid share");let t=$(St,this.namespace),n=new Set([...this.shares,e]),s=Array.from(n);return this.storage.setItem(t,JSON.stringify(s)),this.fireSharesEvent(),s}removeShare(e){let t=this.shares,n=t.findIndex(i=>i===e);if(n===-1)return new f("That share is not known yet");t.splice(n,1);let s=$(St,this.namespace);return this.storage.setItem(s,JSON.stringify(t)),this.fireSharesEvent(),t}get shareSecrets(){let e=$(Dt,this.namespace);return hr(this.storage,e,zi)||{}}async addSecret(e,t){if(!this.shares.find(a=>e===a))return new f("This share is not yet known.");if(w(await F.checkKeypairIsValid({shareAddress:e,secret:t})))return new f("Not the right secret for this share.");let s=$(Dt,this.namespace),i={...this.shareSecrets,[e]:t};return this.storage.setItem(s,JSON.stringify(i)),this.fireSecretsEvent(),i}removeSecret(e){let t=this.shareSecrets;if(!t[e])return new f("Unknown share");let s=$(Dt,this.namespace),i={...t};return delete i[e],this.storage.setItem(s,JSON.stringify(i)),this.fireSecretsEvent(),i}get servers(){let e=$(xt,this.namespace);return hr(this.storage,e,Gi)||[]}addServer(e){try{let t=new URL(e),n=new Set([...this.servers,t.toString()]),s=Array.from(n),i=$(xt,this.namespace);return this.storage.setItem(i,JSON.stringify(s)),this.fireServersEvent(),s}catch{return new f("Not a valid URL.")}}removeServer(e){try{let t=new URL(e),n=this.servers,s=n.findIndex(a=>a===t.toString());if(s===-1)return new f("That server is not known yet");n.splice(s,1);let i=$(xt,this.namespace);return this.storage.setItem(i,JSON.stringify(n)),this.fireServersEvent(),n}catch{return new f("Not a valid URL")}}clear(){let e=$(dr,this.namespace);this.storage.setItem(e,JSON.stringify(null));let t=$(St,this.namespace);this.storage.setItem(t,JSON.stringify([]));let n=$(Dt,this.namespace);this.storage.setItem(n,JSON.stringify({}));let s=$(xt,this.namespace);this.storage.setItem(s,JSON.stringify([])),this.fireAuthorEvent(),this.fireSharesEvent(),this.fireSecretsEvent(),this.fireServersEvent()}onAuthorChanged(e){return this.authorChangedCbs.add(e),()=>{this.authorChangedCbs.delete(e)}}onSharesChanged(e){return this.sharesChangedCbs.add(e),()=>{this.sharesChangedCbs.delete(e)}}onShareSecretsChanged(e){return this.shareSecretsChangedCbs.add(e),()=>{this.shareSecretsChangedCbs.delete(e)}}onServersChanged(e){return this.serversChangedCbs.add(e),()=>{this.serversChangedCbs.delete(e)}}getPeer({sync:e,onCreateReplica:t}){let n=new st,s=this.shares;for(let l of s){let h=t(l,this.shareSecrets[l]);n.addReplica(h)}let i=this.onSharesChanged(async l=>{let h=n.replicas(),d=n.shares();for(let u of h)l.includes(u.share)||(n.removeReplica(u),await u.close(!1));for(let u of l)if(!d.includes(u)){let p=t(u,this.shareSecrets[u]);n.addReplica(p)}}),a=this.onShareSecretsChanged(async l=>{let h=n.shares(),d=Object.keys(l);for(let u of h)if(!d.includes(u)){let p=n.getReplica(u);p&&(n.removeReplica(p),p.close(!1));let m=t(u);n.addReplica(m)}for(let u of d){let p=n.getReplica(u);if(p?.formatsConfig["es.5"]&&p.formatsConfig["es.5"].shareSecret)continue;await p?.close(!1),n.removeReplicaByShare(u);let m=t(u,l[u]);n.addReplica(m)}});if(e)for(let l of this.servers)n.sync(l,e==="continuous");let o=this.onServersChanged(l=>{if(e){let h=n.getSyncers();for(let[d,{description:u,syncer:p}]of h)l.includes(u)||p.cancel();for(let d of l)n.sync(d,e==="continuous")}});return{peer:n,unsubscribeFromSettings:()=>{i(),a(),o()}}}fireAuthorEvent(){let e=this.author;for(let t of this.authorChangedCbs)t(e)}fireSharesEvent(){let e=this.shares;for(let t of this.sharesChangedCbs)t(e)}fireSecretsEvent(){let e=this.shareSecrets;for(let t of this.shareSecretsChangedCbs)t(e)}fireServersEvent(){let e=this.servers;for(let t of this.serversChangedCbs)t(e)}async redeemInvitationURL(e){let t=await ps(e);if(w(t))return t;this.addShare(t.shareAddress);for(let n of t.servers)this.addServer(n);return t.secret&&this.addSecret(t.shareAddress,t.secret),!0}};function $(r,e){return`${Qi}:${e?`${e}:`:""}${r}`}function hr(r,e,t){let n=r.getItem(e);if(n!==null)try{let s=JSON.parse(n);return t(s)?s:void 0}catch{return}}function ms(r){return!(r==null||typeof r!="object")}function ji(r){return!(!ms(r)||Object.keys(r).length!==2||!("address"in r)||!("secret"in r))}function Hi(r){return!(!Array.isArray(r)||r.some(e=>typeof e!="string")||r.some(e=>w(X(e))))}function zi(r){if(!ms(r))return!1;for(let e in r){let t=r[e];if(typeof t!="string"||w(F.checkKeypairIsValid({shareAddress:e,secret:t})))return!1}return!0}function Gi(r){if(!Array.isArray(r)||r.some(e=>typeof e!="string"))return!1;for(let e of r)try{new URL(e)}catch{return!1}return!0}var ke=new R("storage driver localStorage","gold");function Ji(r){return typeof r!="object"?!1:"byPathAndAuthor"in r&&"byPathNewestFirst"in r}var Gr=class extends ot{constructor(t,n){super(t);ke.debug("constructor"),this._localStorageKeyConfig=`earthstar:config:${t}${n?`:${n}`:""}`,this._localStorageKeyDocs=`earthstar:documents:${t}${n?`:${n}`:""}`;let s=localStorage.getItem(this._localStorageKeyDocs);if(s!==null){ke.debug("...constructor: loading data from localStorage");let i=JSON.parse(s);if(!Ji(i)){console.warn(`localStorage data could not be parsed for share ${t}`);return}this.docByPathAndAuthor=new Map(Object.entries(i.byPathAndAuthor)),this.docsByPathNewestFirst=new Map(Object.entries(i.byPathNewestFirst)),this.latestDocsByPath=new Map(Object.entries(i.latestDocsByPath));let a=Array.from(this.docByPathAndAuthor.values()).map(o=>o._localIndex);this._maxLocalIndex=Math.max(...a)}else ke.debug("...constructor: there was no existing data in localStorage");ke.debug("...constructor is done.")}close(t){if(ke.debug("close"),this._isClosed)throw new A;if(t){ke.debug("...close: and erase"),this._configKv={},this._maxLocalIndex=-1,this.docsByPathNewestFirst.clear(),this.docByPathAndAuthor.clear(),ke.debug("...close: erasing localStorage"),localStorage.removeItem(this._localStorageKeyDocs);for(let n of this._listConfigKeysSync())this._deleteConfigSync(n);ke.debug("...close: erasing is done")}return this._isClosed=!0,ke.debug("...close is done."),Promise.resolve()}_getConfigSync(t){if(this._isClosed)throw new A;t=`${this._localStorageKeyConfig}:${t}`;let n=localStorage.getItem(t);return n===null?void 0:n}_setConfigSync(t,n){if(this._isClosed)throw new A;t=`${this._localStorageKeyConfig}:${t}`,localStorage.setItem(t,n)}_listConfigKeysSync(){if(this._isClosed)throw new A;let t=Object.keys(localStorage).filter(n=>n.startsWith(this._localStorageKeyConfig+":")).map(n=>n.slice(this._localStorageKeyConfig.length+1));return t.sort(),t}_deleteConfigSync(t){if(this._isClosed)throw new A;let n=this._getConfigSync(t);return t=`${this._localStorageKeyConfig}:${t}`,localStorage.removeItem(t),n!==void 0}async getConfig(t){return this._getConfigSync(t)}async setConfig(t,n){return this._setConfigSync(t,n)}async listConfigKeys(){return this._listConfigKeysSync()}async deleteConfig(t){return this._deleteConfigSync(t)}async upsert(t){if(this._isClosed)throw new A;let n=await super.upsert(t),s={byPathAndAuthor:Object.fromEntries(this.docByPathAndAuthor),byPathNewestFirst:Object.fromEntries(this.docsByPathNewestFirst),latestDocsByPath:Object.fromEntries(this.latestDocsByPath)};return localStorage.setItem(this._localStorageKeyDocs,JSON.stringify(s)),n}};var Qe=new R("replica driver indexeddb","gold");function Yi(r,e){return Ie([r.path,r.timestamp,r.signature],[e.path,e.timestamp,r.signature],["ASC","DESC","ASC"])}function Zi(r,e){return Ie([r.path,r.timestamp,r.signature],[e.path,e.timestamp,r.signature],["DESC","DESC","ASC"])}var ie="docs",me="config",Et=class{constructor(e,t){this.db=T();this.gotInitialMaxLocalIndex=T();this.localMaxLocalIndex=-1;this.closed=!1;let n=X(e);if(w(n))throw n;if(this.share=e,Qe.debug("constructor"),!window.indexedDB)throw new P("IndexedDB is not supported by this runtime.");let s=window.indexedDB.open(`earthstar:share_docs:${this.share}${t?`/${t}`:""}`,1);s.onerror=()=>{throw Qe.error(`Could not open IndexedDB for ${this.share}'s attachments.`),Qe.error(s.error),new P(`Could not open IndexedDB for ${this.share}'s attachments.`)},s.onupgradeneeded=function(){let i=s.result,a=i.createObjectStore(ie,{keyPath:["path","author"]});a.createIndex("comboIndex",["_localIndex","timestamp","path","author"],{unique:!0}),a.createIndex("pathTimestampIndex",["path","timestamp"],{unique:!1}),a.createIndex("pathAuthorIndex",["path","author"],{unique:!0}),a.createIndex("deleteAfterIndex","deleteAfter",{unique:!1}),a.createIndex("localIndexIndex","_localIndex",{unique:!0}),i.createObjectStore(me,{keyPath:"key"}).createIndex("keyIndex",["key"],{unique:!0})},s.onsuccess=()=>{this.db.resolve(s.result);let a=s.result.transaction([ie],"readonly").objectStore(ie).index("localIndexIndex").openCursor(null,"prev");a.onsuccess=()=>{a.result?this.gotInitialMaxLocalIndex.resolve(a.result.value._localIndex):this.gotInitialMaxLocalIndex.resolve(-1)}},this.gotInitialMaxLocalIndex.then(i=>{this.localMaxLocalIndex=i})}isClosed(){return this.closed}async close(e){if(this.closed)throw new A;this.closed=!0;let t=T();if(e){let s=(await this.db).transaction([ie,me],"readwrite"),i=T(),a=T(),o=s.objectStore(ie).clear().onsuccess=()=>{i.resolve()},c=s.objectStore(me).clear().onsuccess=()=>{a.resolve()};await Promise.all([o,c]),t.resolve()}else t.resolve();return(await this.db).close(),await Ht(20),t}async getMaxLocalIndex(){return await this.gotInitialMaxLocalIndex,this.localMaxLocalIndex}async queryDocs(e){let n=(await this.db).transaction([ie],"readonly").objectStore(ie),s=T(),{query:i,willMatch:a}=it(e);if(Qe.debug(`    cleanUpQuery.  willMatch = ${a}`),a==="nothing")return[];if(i.filter?.path&&i.historyMode==="latest"){let h=IDBKeyRange.bound([i.filter.path,i.filter.timestampGt||0],[i.filter.path,i.filter.timestampLt||Number.MAX_SAFE_INTEGER]),u=n.index("pathTimestampIndex").openCursor(h,"prev");u.onsuccess=()=>{u.result?.value?s.resolve([u.result.value]):s.resolve([])}}else if(i.filter?.path&&i.historyMode==="all"){let h=n.index("pathAuthorIndex"),d=IDBKeyRange.bound([i.filter.path," "],[i.filter.path,"~"]),u=h.getAll(d);u.onsuccess=()=>{u.result?s.resolve(Array.from(u.result)):s.resolve([])}}else{let h=i.startAfter?.path||i.filter?.path||i.filter?.pathStartsWith||" ",d=i.filter?.author||" ",u=i.filter?.timestamp||i.filter?.timestampGt||0,p=i.startAfter?.localIndex||0,m=i.filter?.path||"~",g=i.filter?.author||"~",v=i.filter?.timestamp||i.filter?.timestampLt||Number.MAX_SAFE_INTEGER,S=Number.MAX_SAFE_INTEGER,_=IDBKeyRange.bound([p,u,h,d],[S,v,m,g]),D=n.index("comboIndex").getAll(_);D.onsuccess=()=>{D.result?s.resolve(D.result):s.resolve([])}}let o=await s;if(i.historyMode==="latest"){let h=o.splice(0,o.length),d=new Map;for(let u of h){let p=d.get(u.path);(!p||p.timestamp<u.timestamp)&&d.set(u.path,u)}o.push(...d.values())}let c=[];Qe.debug("    filtering docs");let l=Date.now()*1e3;for(let h of o)h.deleteAfter&&h.deleteAfter<l||i.filter&&!Le(h,i.filter)||c.push(h);if(Qe.debug(`    ordering docs: ${i.orderBy}`),i.orderBy==="path ASC")c.sort(Yi);else if(i.orderBy==="path DESC")c.sort(Zi);else if(i.orderBy==="localIndex ASC")c.sort(at("_localIndex","ASC"));else if(i.orderBy==="localIndex DESC")c.sort(at("_localIndex","DESC"));else if(i.orderBy)throw new f("unrecognized query orderBy: "+JSON.stringify(i.orderBy));return i.limit!==void 0&&o.length>=i.limit?c.slice(0,i.limit):(Qe.debug(`    queryDocs is done: found ${c.length} docs.`),c)}async upsert(e){let t=await this.db,s=t.transaction([ie],"readwrite").objectStore(ie).index("pathAuthorIndex"),i=T(),a=s.openCursor([e.path,e.author]);if(await this.gotInitialMaxLocalIndex,this.localMaxLocalIndex+=1,e._localIndex=this.localMaxLocalIndex,a.onsuccess=()=>{if(a.result){let d=a.result.update(e);d.onsuccess=()=>{i.resolve(!!d.result)}}else i.resolve(!1)},await i)return e;let l=t.transaction([ie],"readwrite").objectStore(ie).put(e),h=T();return l.onsuccess=()=>{h.resolve()},l.onerror=()=>{throw l.error},await h,e}async eraseExpiredDocs(){let e=[],s=(await this.db).transaction([ie],"readwrite").objectStore(ie).index("deleteAfterIndex"),i=Date.now()*1e3,a=IDBKeyRange.bound(0,i),o=s.openCursor(a),c=T();return o.onsuccess=()=>{if(o.result?.value){let l=o.result.value;if(l.deleteAfter!==null&&l.deleteAfter!==void 0){e.push(l);let h=o.result.delete();h.onsuccess=()=>{o.result?.continue()}}}else c.resolve()},await c,e}async getConfig(e){let n=(await this.db).transaction([me],"readonly").objectStore(me),s=T(),i=n.get(e);return i.onsuccess=()=>{s.resolve(i.result?.value)},s}async setConfig(e,t){let s=(await this.db).transaction([me],"readwrite").objectStore(me),i=T(),a=s.put({key:e,value:t});return a.onsuccess=()=>{i.resolve()},i}async listConfigKeys(){let t=(await this.db).transaction([me],"readonly").objectStore(me),n=T(),i=t.index("keyIndex").openKeyCursor(),a=[];return i.onsuccess=()=>{i.result?(a.push(i.result.primaryKey),i.result.continue()):n.resolve(a)},n}async deleteConfig(e){let n=(await this.db).transaction([me],"readwrite").objectStore(me),s=T(),i=n.index("keyIndex"),a=IDBKeyRange.bound([e],[e]),o=i.openCursor(a);return o.onsuccess=()=>{if(o.result){let c=o.result.delete();c.onsuccess=()=>{s.resolve(!0)}}else s.resolve(!1)},s}};var gs=new R("replica driver indexeddb","gold"),ge="attachment_staging_index",ae="attachments_index",ne="attachments_bytes",It=class{constructor(e,t){this.db=T();this.closed=!1;if(this.share=e,!window.indexedDB)throw new P("IndexedDB is not supported by this runtime.");let n=window.indexedDB.open(`earthstar:share_attachments:${this.share}${t?`/${t}`:""}`,1);n.onerror=()=>{throw gs.error(`Could not open IndexedDB for ${this.share}'s attachments.`),gs.error(n.error),new P(`Could not open IndexedDB for ${this.share}'s attachments.`)},n.onupgradeneeded=function(){let s=n.result;s.createObjectStore(ne),s.createObjectStore(ae,{keyPath:"id"}),s.createObjectStore(ge,{keyPath:"id"})},n.onsuccess=()=>{this.db.resolve(n.result)}}getIndexKey(e,t){return`${e}___${t}`}async getAttachment(e,t){if(this.closed)throw new A;let n=T(),s=this.getIndexKey(e,t),i=await this.db,o=i.transaction([ae],"readonly").objectStore(ae).get(s),c=T();return o.onerror=()=>{c.reject()},o.onsuccess=()=>{o.result===void 0?c.reject():c.resolve(o.result.blobKey)},c.then(l=>{let d=i.transaction([ne],"readonly").objectStore(ne).get(l);d.onsuccess=()=>{let u=new Blob([d.result]);n.resolve({bytes:async()=>new Uint8Array(await u.arrayBuffer()),stream:()=>Promise.resolve(u.stream())})},d.onerror=()=>{n.resolve(void 0)}}).catch(()=>{n.resolve(void 0)}),n}async erase(e,t){if(this.closed)throw new A;let n=T(),s=this.getIndexKey(e,t),i=await this.db,o=i.transaction([ae],"readonly").objectStore(ae).get(s),c=T();return o.onerror=()=>{c.reject()},o.onsuccess=()=>{i.transaction([ae],"readwrite").objectStore(ae).delete(s),o.result===void 0?c.reject():c.resolve(o.result.blobKey)},c.then(l=>{let h=i.transaction([ne],"readwrite").objectStore(ne).delete(l);h.onsuccess=()=>{n.resolve(!0)},h.onerror=()=>{n.resolve(void 0)}}).catch(()=>{n.resolve(new f("No attachment found"))}),n}async stage(e,t){if(this.closed)throw new A;let n=await this.db,s=t instanceof Uint8Array?t:await lr(t),i=await F.sha256base32(s),a=this.getIndexKey(e,i),o=`${a}___${re()}`,c=n.transaction([ne,ge],"readwrite"),l=c.objectStore(ne).put(s,o),h=c.objectStore(ge).put({id:a,blobKey:o}),d=T(),u=T();return l.onsuccess=()=>d.resolve(),h.onsuccess=()=>u.resolve(),await d,await u,{hash:i,size:s.byteLength,reject:async()=>{let p=n.transaction([ne,ge],"readwrite"),m=p.objectStore(ne).delete(o),g=p.objectStore(ge).delete(a),v=T(),S=T();m.onsuccess=()=>{v.resolve()},g.onsuccess=()=>{S.resolve()},await Promise.all([v,S])},commit:async()=>{let p=n.transaction([ae,ge],"readwrite"),m=p.objectStore(ge).delete(a),g=p.objectStore(ae).put({id:a,blobKey:o}),v=T(),S=T();m.onsuccess=()=>v.resolve(),g.onsuccess=()=>S.resolve(),await Promise.all([v,S])}}}async wipe(){if(this.closed)throw new A;let t=(await this.db).transaction([ne,ae,ge],"readwrite"),n=t.objectStore(ne).clear(),s=t.objectStore(ae).clear(),i=t.objectStore(ge).clear(),a=T(),o=T(),c=T();n.onsuccess=()=>a.resolve(),s.onsuccess=()=>o.resolve(),i.onsuccess=()=>c.resolve(),await Promise.all([a,o,c])}async clearStaging(){if(this.closed)throw new A;let t=(await this.db).transaction([ne,ge]),n=t.objectStore(ge).openCursor(),s=T();return n.onsuccess=()=>{let i=n.result;if(!i){s.resolve();return}let a=i.value.blobKey,o=t.objectStore(ne).delete(a);i.delete(),o.onsuccess=()=>{i.continue()},o.onerror=()=>{i.continue()}},s}async filter(e){if(this.closed)throw new A;let n=(await this.db).transaction([ne,ae],"readwrite"),s=50,i=[],a=[],o=T(),c=(l=null)=>{let h=n.objectStore(ae).getAll(l,s);h.onsuccess=()=>{let d=h.result;for(let u of d){let[p,m]=u.id.split("___");e[p]&&!e[p].has(m)&&(i.push({format:p,hash:m}),a.push(this.erase(p,m)))}if(d.length===s){let u=d[d.length-1],p=IDBKeyRange.lowerBound(u.id,!0);c(p)}else o.resolve()}};return c(),await o,await Promise.all(a),i}isClosed(){return this.closed}async close(e){if(this.closed)throw new A;e&&await this.wipe(),this.closed=!0,(await this.db).close(),await Ht(20)}};var Jr=class{constructor(e,t){this.docDriver=new Et(e,t),this.attachmentDriver=new It(e,t)}};export{It as AttachmentDriverIndexedDB,ur as AttachmentDriverMemory,zr as Cmp,en as ConnectionRefusedError,F as Crypto,_n as CryptoDriverNoble,se as DEFAULT_FORMAT,Xe as DEFAULT_FORMATS,Ti as DEFAULT_LOG_LEVEL,es as DEFAULT_QUERY,Et as DocDriverIndexedDB,Gr as DocDriverLocalStorage,ot as DocDriverMemory,P as EarthstarError,Dc as FormatEs4,Gn as FormatEs5,Fe as GlobalCryptoDriver,bi as LogLevel,R as Logger,cr as MultiformatReplica,Zr as NetworkError,tn as NotImplementedError,ce as NotSupportedError,rr as PartnerLocal,Xn as PartnerWebClient,st as Peer,as as Replica,ls as ReplicaCache,ye as ReplicaCacheIsClosedError,hs as ReplicaDriverMemory,Jr as ReplicaDriverWeb,A as ReplicaIsClosedError,fs as SharedSettings,nt as Syncer,Xr as TimeoutError,f as ValidationError,qi as _matchAll,Ve as alphaLower,yi as alphaUpper,Kt as assembleAuthorAddress,Wt as assembleShareAddress,Ut as authorAddressChars,Cn as authorKeyChars,Ir as authorNameChars,le as b32chars,wo as b64StringToBytes,ue as base32BytesToString,Ze as base32StringToBytes,go as bytesToString,Je as checkAuthorIsValid,qe as checkInt,Bo as checkIsPlainObject,$t as checkLiteral,Qt as checkObj,X as checkShareIsValid,z as checkString,it as cleanUpQuery,Ie as compareArrays,or as compareBasic,Ou as compareByFn,Vu as compareByObjArrayFn,at as compareByObjKey,yo as concatBytes,Pr as countChars,Ed as createInvitationURL,Un as decodeKeypairToBytes,Nt as digits,ts as docIsExpired,Le as docMatchesFilter,Zo as encodeAuthorKeypairToStrings,Xo as encodeShareKeypairToStrings,Vi as escapeStringForRegex,Pu as extractTemplateVariablesFromPath,Ki as extractTemplateVariablesFromPathUsingRegex,Ho as generateShareAddress,Jn as getFormatIntersection,ve as getFormatLookup,_r as getFormatWithFallback,Ee as getFormatsWithFallback,vi as getLogLevel,No as getLogLevels,rs as globToQueryAndRegex,At as globToRegex,bo as identifyBufOrBytes,Fu as insertVariablesIntoTemplate,Fr as isAuthorKeypair,gi as isBuffer,mi as isBytes,Er as isDigit,w as isErr,Nn as isObjectEmpty,Ao as isOnlyPrintableAscii,Ye as isPlainObject,Cr as microsecondNow,mr as notErr,mt as onlyHasChars,Fn as parseAddress,Pn as parseAuthorAddress,gt as parseAuthorOrShareAddress,ps as parseInvitationURL,yt as parseShareAddress,ns as parseTemplate,qt as pathChars,wi as pathPunctuation,Cu as queryByGlob,Lu as queryByTemplate,re as randomId,wt as replaceAll,_o as setDefaultLogLevel,ic as setGlobalCryptoDriver,Mo as setLogLevel,Ht as sleep,ss as sortedInPlace,Rn as stringLengthInBytes,Ge as stringToBytes,Lo as updateLogLevels,Vt as workspaceAddressChars,Ot as workspaceKeyChars,kr as workspaceNameChars};
/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
//# sourceMappingURL=earthstar.web.v10.2.2.js.map
